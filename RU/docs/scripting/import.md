# Import
Размещение всего кода в одном файле быстро становится неуправляемым. 
Инструкции `import` позволяют импортировать функции и глобальные переменные из другого файла.

`import filename`

Это простейшая форма инструкции import. Она даст вам доступ ко всему, что определено в файле с именем `filename`. Каждое окно в игре — это файл, а имя файла — это имя, отображаемое вверху окна.

Вот пример с двумя файлами:
Файл с именем helper:
`x = 0

def say_hello():
    print("привет из helper")`

Какой-то другой файл:
`import helper
helper.say_hello()
helper.x += 1`

Здесь `import helper` выполняет файл с именем `helper` и даёт вам доступ ко всем его глобальным переменным.
Затем вы можете обращаться к переменным и функциям внутри импортированного модуля, используя оператор `.`.
Так, в этом примере `helper.say_hello()` вызывает `say_hello()` внутри helper, а последняя строка увеличивает глобальную переменную x.

Вы также можете переместить глобальные переменные из импортированного модуля в текущую область видимости, где выполняется инструкция import, используя синтаксис `from`.

`from helper import *`
Импортирует все глобальные переменные из helper.

или

`from helper import say_hello`
Импортирует только указанные глобальные переменные из helper.

Это также импортирует файл helper, но вместо доступа к нему через переменную с именем `helper`, он распаковывает глобальные переменные из `helper` и присваивает их непосредственно в локальной области видимости.

`from helper import say_hello
say_hello()`

Эта форма импорта обычно не рекомендуется, потому что она плохо работает, когда два файла импортируют друг друга, и вы можете случайно перезаписать переменные в импортирующем файле из-за конфликтов имён.

# Как это на самом деле работает

## Короче говоря
Импорты могут быть довольно неинтуитивными, но большинство проблем можно избежать, придерживаясь синтаксиса `import file` вместо `from file import`, и оборачивая всё, что не является глобальным определением, в
`if __name__ == "__main__":`

## Побочные эффекты импорта
Когда вы импортируете файл в первый раз, он выполнит весь файл, а затем даст вам доступ ко всем переменным, которые были определены во время выполнения.
Если вы импортируете тот же файл снова, он просто вернёт кешированный модуль с первого раза.

Это означает, что инструкции import могут иметь побочные эффекты. Если вы импортируете файл, который вызывает `harvest()`, он действительно соберёт урожай во время импорта. Но когда вы импортируете его снова, он не будет собирать урожай, потому что файл запускается только один раз.

Есть способ избежать таких побочных эффектов, используя переменную `__name__`. Это переменная, которой автоматически присваивается значение `"__main__"`, когда файл запускается напрямую, и имя файла, когда файл запускается через `import`.
Считается хорошей практикой помещать любой код, который вы не хотите выполнять при импорте файла, в блок `if __name__ == "__main__":`.

Общая структура файла в Python — это помещать код, который должен быть выполнен при запуске файла, в функцию `main()`. Таким образом, у вас есть чёткое различие между локальными переменными (определёнными внутри `main()`) и глобальными переменными, которые можно импортировать (определёнными вне `main()`).

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # делать вещи

if __name__ == "__main__":
    main()`

## Циклические импорты
Что произойдёт, если файл `a` импортирует файл `b`, а файл `b` импортирует файл `a`?

файл `a`:
`import b
x = 0`

файл `b`:
`import a
def f():
    print(a.x)`

Это будет работать нормально. Допустим, ни один из двух файлов ещё не загружен, и кто-то другой выполняет `import a`.

-`a` выполняется до строки `import b`.
-`b` выполняется до строки `import a`.
-Модуль `a` уже существует, но не содержит `x`, потому что он дошёл только до строки `import b`.
-`b` сохраняет ссылку на наполовину загруженный модуль `a` в переменной с именем `a`.
-`b` выполняет инструкцию `def` и сохраняет функцию `f()`.
-`a` продолжает выполняться и инициализирует `x`.

Когда кто-то вызовет `b.f()`, он правильно напечатает `0`, потому что модуль `a`, на который `b` имеет ссылку, теперь полностью загружен.

Теперь рассмотрим тот же код с использованием синтаксиса `from`.

файл `a`:
`from b import *
x = 0`

файл `b`:
`from a import *
def f():
    print(x)`

-`a` выполняется до строки `from b import *`.
-`b` выполняется до строки `from a import *`.
-Модуль `a` уже существует, но ещё не был полностью выполнен.
-`b` распаковывает всё, что в настоящее время находится в `a`, в свою собственную глобальную область видимости. На данный момент `a` ничего не содержит, потому что он ещё не дошёл до строки `x = 0`, поэтому ничего не импортируется.
-`b` выполняет инструкцию `def` и сохраняет функцию `f()`.
-`a` продолжает выполняться и инициализирует `x`.

Если кто-то теперь вызовет `b.f()`, он получит ошибку, что `x` не существует в текущей области видимости. Это потому, что на этот раз `b` не имеет ссылки на всё ещё загружающийся `a` и не видит определения, которые были добавлены после импорта.