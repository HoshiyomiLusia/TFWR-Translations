# メガファーム
この信じられないほど強力なアンロックは、農場のサイズを大幅に増加させ、複数のドローンへのアクセスを可能にします。

物事を簡単にするため、新しいドローンごとに常に正確に36の新しいタイルを受け取ります。ドローンとタイルの比率は一定に保たれます。

## 複数のドローン
以前と同様に、最初は1台のドローンから始まります。追加のドローンは最初にスポーンさせる必要があり、プログラムが終了すると消えます。
各ドローンは独自の独立したプログラムインスタンスを実行します。ドローンは次のようにして新しいドローンをスポーンできます
`new_drone_id = spawn_drone("filename")`

これにより、`spawn_drone("filename")`コマンドを実行したドローンと同じ位置に新しいドローンがスポーンします。新しいドローンは`filename`という名前のファイル内のプログラムの実行を開始しますので、`"filename"`を実行したいファイルの名前に置き換えてください。

これは、ドローンに`filename`という名前のファイルに行き、次のドローンの実行ボタンを押すように指示したと考えることができます。

ドローンは互いに衝突しません。

スポーンできるドローンの最大数を取得するには`max_drones()`を使用します。
すでに農場にいるドローンの数を取得するには`num_drones()`を使用します。
どのドローンがコードを実行しているかを知るには`get_drone_id()`を使用します。

例:

`farming routine`という名前のファイル内:
`if get_drone_id() == 0:
    # 最初のドローンのみがこれを実行します
    while num_drones() < max_drones():
        spawn_drone("farming routine")
        move(East)

while True:
    if can_harvest():
        harvest()
    move(North)`

これにより、最初のドローンが水平に移動してより多くのドローンをスポーンさせます。スポーンされたドローンはその後、垂直に移動して進路上のすべてを収穫します。

<spoiler=ヒントを表示>
複数のドローンを使用する最も簡単な方法は、農場をそれらの間で分割することです。アップグレードは、各ドローンが常に6x6の畑を持てるように設計されています。
</spoiler>

ここから下はかなり高度な内容で、基本的な農業には必要ありません

## 競合状態
複数のドローンが同時に同じ農場タイルとやり取りすることがあります。2台のドローンがまったく同じtickに同じタイルとやり取りした場合、drone IDが小さい方のドローンのアクションが先に発生します。

例えば、ドローン`0`と`1`が両方とも、ほぼ完全に成長した同じ木の上にいると想像してください。
ドローン`0`は呼び出します
`use_item(Items.Fertilizer)`
ドローン`1`は呼び出します
`harvest()`

これらのアクションが同時に発生した場合、木は最初に施肥されてから収穫されます。その場合、木材を受け取ることになります。しかし、ドローン`1`がわずかに速い場合、木は施肥される前に収穫され、木材は受け取れません。
これは「競合状態」と呼ばれます。これは並列プログラミングで一般的な問題で、結果が操作の実行順序に依存します。

複数のドローンが同じ位置で同時に同じコードを実行すると発生する可能性のある、もう一つの問題のある状況です。
`if get_water() < 0.5:
    use_item(Items.Water)`

複数のドローンがこれを同時に実行すると、それらはすべて最初の行を実行し、`if`ブロックに入ります。その後、それらはすべて水を使用し、多くの水を無駄にします。
あるドローンが2行目に到達するまでに、別のドローンがその間にタイルに水やりをしたため、`get_water()`はもはや`0.5`未満ではないかもしれません。

## ドローン通信
より高度な戦略に興味がある場合は、メッセージパッシング関数を使用してドローン同士が通信するようにしたいかもしれません。

別のドローンに任意の値を送信します:
`send(data, receiver_drone_id)`

任意のドローンから送信された次の値を受信します:
`data = receive()`

特定のドローンから送信された次の値を受信します:
`data = receive(sender_drone_id)`

`send()`の実行時間は送信されるデータのサイズに依存します。例えば、大きなdictionaryを送信するにはコピーが必要で、時間がかかることがあります。

`receive()`はメッセージが到着するのを待ちません。まだメッセージが送信されていない場合、`None`を返します。

このようにしてメッセージを待つ関数を構築できます:
`def blocking_receive(sender_drone_id = -1):
    while True:
        data = receive(sender_drone_id)
        if data != None:
            return data`

メッセージを渡す便利な応用例の一つは、ドローンをスポーンして実行する関数を送信する関数を持つことです。
`drone_spawning`という名前のファイル内:
`def run_on_new_drone(f):
    id = spawn_drone("drone_spawning")
    send(f, id)

if __name__ == "__main__":
    f = blocking_receive()
    f()`

このように関数を送信すると、すべてのグローバル変数を含む関数のキャプチャされた状態すべてをコピーする必要があるため、非常に遅くなる可能性があります。
