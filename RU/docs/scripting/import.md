# Импорт
Хранить весь код в одном файле быстро становится неудобно. 
Инструкции `import` позволяют вам импортировать функции и глобальные переменные из другого файла.

`import filename`

Это простейшая форма инструкции import. Она даст вам доступ ко всему, что определено в файле с именем `filename`. Каждое окно в игре — это файл, а имя файла — это имя, отображаемое вверху окна.

Вот пример с двумя файлами:
Файл с именем helper:
`x = 0

def say_hello():
    print("hello from helper")`

Какой-то другой файл:
`import helper
helper.say_hello()
helper.x += 1`

Здесь `import helper` выполняет файл с именем `helper` и даёт вам доступ ко всем его глобальным переменным.
Затем вы можете получить доступ к переменным и функциям внутри импортированного модуля с помощью оператора `.`.
Так, в этом примере `helper.say_hello()` вызывает `say_hello()` внутри helper, а последняя строка увеличивает глобальную переменную x.

Вы также можете переместить глобальные переменные из импортированного модуля в текущую область видимости, где выполняется инструкция import, используя синтаксис `from`.

`from helper import *`
Импортирует все глобальные переменные из helper.

или

`from helper import say_hello`
Импортирует только указанные глобальные переменные из helper.

Это также импортирует файл helper, но вместо доступа к нему через переменную с именем `helper`, он распаковывает глобальные переменные из `helper` и присваивает их непосредственно в локальной области видимости.

`from helper import say_hello
say_hello()`

Эта форма импорта обычно не рекомендуется, потому что она плохо работает, когда два файла импортируют друг друга, и вы можете случайно перезаписать переменные в импортирующем файле из-за совпадения имён.

# Как это работает на самом деле

## Короче говоря
Импорты могут быть довольно неинтуитивными, но большинства проблем можно избежать, придерживаясь синтаксиса `import file` вместо `from file import` и оборачивая всё, что не является определением глобальной переменной, в
`if __name__ == "__main__":`

## Побочные эффекты импорта
Когда вы импортируете файл в первый раз, он выполнит весь файл целиком, а затем предоставит вам доступ ко всем переменным, которые были определены во время выполнения.
Если вы импортируете тот же файл снова, он просто вернёт кэшированный модуль с первого раза.

Это означает, что инструкции import могут иметь побочные эффекты. Если вы импортируете файл, который вызывает `harvest()`, он действительно соберёт урожай во время импорта. Но когда вы импортируете его снова, он больше не будет собирать урожай, потому что файл выполняется только один раз.

Есть способ избежать таких побочных эффектов с помощью переменной `__name__`. Это переменная, которой автоматически присваивается значение `"__main__"`, когда файл запускается напрямую, и имя файла, когда файл запускается через `import`.
Считается хорошей практикой помещать любой код, который вы не хотите выполнять при импорте файла, в блок `if __name__ == "__main__":`.

Обычная структура файла в Python — помещать код, который должен выполняться при запуске файла, в функцию `main()`. Таким образом, у вас есть чёткое различие между локальными переменными (определёнными внутри `main()`) и глобальными переменными, которые можно импортировать (определёнными вне `main()`).

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # делать что-то

if __name__ == "__main__":
    main()`

## Циклические импорты
Что произойдёт, если файл `a` импортирует файл `b`, а файл `b` импортирует файл `a`?

файл `a`:
`import b
x = 0`

файл `b`:
`import a
def f():
    print(a.x)`

Это будет работать нормально. Допустим, ни один из двух файлов ещё не загружен, и кто-то другой выполняет `import a`.

-`a` выполняется до строки `import b`.
-`b` выполняется до строки `import a`.
-Модуль `a` уже существует, но не содержит `x`, потому что он дошёл только до строки `import b`.
-`b` сохраняет ссылку на наполовину загруженный модуль `a` в переменной с именем `a`.
-`b` выполняет инструкцию `def` и сохраняет функцию `f()`.
-`a` продолжает выполняться и инициализирует `x`.

Когда кто-то вызовет `b.f()`, он правильно выведет `0`, потому что модуль `a`, на который у `b` есть ссылка, теперь полностью загружен.

Теперь рассмотрим тот же код с использованием синтаксиса `from`.

файл `a`:
`from b import *
x = 0`

файл `b`:
`from a import *
def f():
    print(x)`

-`a` выполняется до строки `from b import *`.
-`b` выполняется до строки `from a import *`.
-Модуль `a` уже существует, но ещё не был полностью выполнен.
-`b` распаковывает всё, что в данный момент находится в `a`, в свою собственную глобальную область видимости. На данный момент `a` ничего не содержит, потому что он ещё не дошёл до строки `x = 0`, поэтому ничего не импортируется.
-`b` выполняет инструкцию `def` и сохраняет функцию `f()`.
-`a` продолжает выполняться и инициализирует `x`.

Если кто-то теперь вызовет `b.f()`, он получит ошибку, что `x` не существует в текущей области видимости. Это потому, что на этот раз у `b` нет ссылки на всё ещё загружающийся `a` и он не видит определений, которые были добавлены после импорта.