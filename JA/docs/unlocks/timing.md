# タイミング
もし本当にメソッドを最適化したいなら、このゲームで時間がどのように計測されるかを理解する必要があります。このアンロックは、まさにそのためのものです。

## 新しい関数
物事にかかる時間を計測するための便利な関数が2つあります:

`get_time()`はゲーム開始からの時間を秒単位で返します。

`get_tick_count()`は実行開始から実行されたtick数を返します。

これら2つの関数と`quick_print()`は完全に無料です。それらの呼び出し操作でさえも無料です。

## 実行時の詳細

### 注意
これは現実世界でのパフォーマンスの仕組みとは異なります。これらは、このゲームで一貫性のある理解しやすいタイミングモデルを持つために作られたルールにすぎません。
おそらく、コードを極度に最適化したい場合にのみ、これを気にするでしょう。


コード実行の基本単位は「tick」と呼ばれます。スピードアップグレードやパワーがない場合、実行は毎秒`400` ticksのレートで進みます。

一般に、`+, -, *, /, //, %, and, or, ...`のような2つの値を組み合わせる操作は、実行に1 tickかかります。
単一の値に対する`-`と`not`は無料です。
`if`分岐も、（条件式を評価する時間に加えて）実行に1 tickかかります。
関数呼び出しと変数の読み書きは無料ですが、関数定義は1 tickかかります。
`import`ステートメントは無料です。
`.`演算子でインポートされたモジュールにアクセスするのは無料です。
関数やモジュールが引数や変数代入を介して渡された場合、それを使用すると0ではなく1 tickかかります。
`for`と`while`ループは開始に1 tickかかりますが、イテレーションは無料です（条件/シーケンス式を評価する時間は含みません）。
`return`、`break`、`continue`はすべて無料です。
`pass`は1 tickかかるので、正確な遅延を作成するために使用できます。
データ構造へのインデックス付けは、インデックス演算子に1 tickかかり、dictionaryやsetの場合はキーのサイズに応じて追加のtickがかかります。

組み込み関数が実行にかかるtick数は、各関数のドキュメントに個別に記載されています。