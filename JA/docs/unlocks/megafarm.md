# Mega Farm
この非常に強力なアンロックは、農場のサイズを大幅に拡大し、複数のドローンを利用することができます。

作業を簡単にするために、新しいドローン1体につき必ず36個のタイルが追加されます。ドローンとタイルの比率は一定です。

## 複数のドローン
これまでと同様に、最初は1体のドローンからスタートします。追加のドローンは、まずスポーンする必要があり、プログラムが終了すると消えます。
各ドローンは独自のプログラムインスタンスを実行します。ドローンは
`new_drone_id = spawn_drone("filename")`を使用して新しいドローンをスポーンできます。

これは`spawn_drone("filename")`コマンドを実行したドローンと同じ位置に新しいドローンをスポーンします。新しいドローンは、`filename`という名前のファイルにあるプログラムを実行し始めます。ですので、`"filename"`を実行したいファイルの名前に置き換えてください。

これは、ドローンに`filename`という名前のファイルに行って、次のドローンの実行ボタンをクリックするように指示したかのように考えることができます。

ドローン同士は衝突しません。

`max_drones()`を使って、スポーン可能なドローンの最大数を確認しましょう。
`num_drones()`を使って、すでに農場にいるドローンの数を確認しましょう。
`get_drone_id()`を使って、どのドローンがコードを実行しているかを確認しましょう。

例:

`farming routine`という名前のファイルで:
`if get_drone_id() == 0:
    # 最初のドローンだけがこれを実行します
    while num_drones() < max_drones():
        spawn_drone("farming routine")
        move(East)`

while True:
    if can_harvest():
        harvest()
    move(North)`

これにより、最初のドローンが水平方向に移動し、新しいドローンをスポーンします。スポーンされたドローンは、垂直に移動して通り道のすべてを収穫します。

<spoiler=show hint>複数のドローンを最も簡単に活用する方法は、農場をドローン同士で分けることです。各ドローンが常に6x6のフィールドを持てるようにアップグレードが設定されています。
</spoiler>

### ここから下はかなり高度で、基本的な農業には必要ありません

## レースコンディション
複数のドローンが同じ農場タイルに同時に作用することが可能です。同じ`tick`で2体のドローンが同じタイルに作用する場合、ドローンIDが低い方のドローンのアクションが先に起こります。

例えば、ドローン`0`と`1`がほぼ成長した同じ木の上にいるとします。
ドローン`0`は`use_item(Items.Fertilizer)`を呼び出し、
ドローン`1`は`harvest()`を呼び出します。

もしこれらのアクションが同時に起こっていれば、木は先に肥料を与えられ、その後収穫されます。そのため、木材を得ることができます。しかし、ドローン`1`がわずかに速かった場合、木は肥料を与えられる前に収穫され、木材を得られません。
これは「レースコンディション」と呼ばれます。並行プログラミングにおける共通の問題で、結果が操作の順序に依存します。

同じ位置で複数のドローンが同じコードを同時に実行する場合に起こりうる問題のもう一つの例です。
`if get_water() < 0.5:
    use_item(Items.Water)`

もし複数のドローンがこれを同時に実行すると、全てが最初の行を実行し、`if`ブロックに入ります。そして、全てが水を使用し、多くの水を無駄にします。
ドローンが2行目に到達するまでに、`get_water()`はもはや`0.5`未満ではないかもしれません。なぜなら、他のドローンがその間にタイルに水をやったからです。

## ドローン間の通信
もっと高度な戦略に興味があるなら、メッセージパッシング関数を使ってドローン同士を通信させたいかもしれません。

他のドローンに任意の値を送信:
`send(data, receiver_drone_id)`

どのドローンからでも次に送られてくる値を受信:
`data = receive()`

特定のドローンから次に送られてくる値を受信:
`data = receive(sender_drone_id)`

`send()`の実行時間は送信するデータのサイズに依存します。例えば、大きなdictionaryを送信する際にはコピーが必要になり、少し時間がかかることがあります。

`receive()`はメッセージが到着するのを待ちません。まだメッセージが送信されていない場合、`None`を返します。

メッセージを待機する関数を以下のように構築できます:
`def blocking_receive(sender_drone_id = -1):
    while True:
        data = receive(sender_drone_id)
        if data != None:
            return data`

メッセージを渡すことの有用なアプリケーションの一つは、ドローンをスポーンし、実行すべき関数をそれに送ることです。
`drone_spawning`という名前のファイルにて:
`def run_on_new_drone(f):
    id = spawn_drone("drone_spawning")
    send(f, id)

if __name__ == "__main__":
    f = blocking_receive()
    f()`

このように関数を送信することは非常に遅い場合があります。なぜなら、関数によって捕らえられたすべての状態（すべてのグローバル変数を含む）がコピーされなければならないからです。