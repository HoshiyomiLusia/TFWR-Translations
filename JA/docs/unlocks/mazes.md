# 迷路
植物を[肥料やり](docs/unlocks/fertilizer.md)することで得られる`Items.Weird_Substance`は、茂みに奇妙な効果をもたらします。ドローンが茂みの上にいるときに`use_item(Items.Weird_Substance, amount)`を呼び出すと、茂みが生け垣の迷路に成長します。
迷路のサイズは、使用した`Items.Weird_Substance`の量（`use_item()`呼び出しの2番目の引数）に依存します。
迷路のアップグレードがない場合、`n`個の`Items.Weird_Substance`を使用すると`n`x`n`の迷路になります。迷路のアップグレードレベルごとに宝物が2倍になりますが、必要な`Items.Weird_Substance`の量も2倍になります。
なので、畑全体の迷路を作るには:

`plant(Entities.Bush)
substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, substance)`


なぜか、生け垣はそれほど高そうに見えなくても、ドローンは飛び越えることができません。

生け垣のどこかに宝物が隠されています。宝物に`harvest()`を使うと、迷路の面積に等しいゴールドを受け取ります。（例: 5x5の迷路は25ゴールドを産出します。）

他の場所で`harvest()`を使用すると、迷路は単に消えてしまいます。

`get_entity_type()`は、ドローンが宝物の上にある場合は`Entities.Treasure`に等しく、迷路の他の場所では`Entities.Hedge`に等しくなります。

迷路を再利用しない限り（迷路の再利用方法については下記参照）、迷路にループは含まれません。そのため、ドローンが後戻りせずに同じ位置に戻ることはありません。

壁があるかどうかは、そこを通過しようとすることで確認できます。
`move()`は成功すれば`True`を、そうでなければ`False`を返します。

宝物への行き方がわからない場合は、ヒント1を見てください。このような問題へのアプローチ方法が示されています。


さらなる挑戦として、宝物に再び同量の`Items.Weird_Substance`を使用することで迷路を再利用することもできます。
これにより、宝物の中のゴールドが迷路1つ分増え、迷路内のランダムな位置に移動します。

宝物に`measure()`を使用すると、移動先の位置がタプルとして返されます。
`next_x, next_y = measure()`

宝物が移動するたびに、迷路からランダムな壁が取り除かれることがあります。そのため、再利用された迷路にはループが含まれることがあります。

迷路にループがあると、後戻りせずに同じ場所に戻ることができるため、はるかに難しくなることに注意してください。
迷路を再利用しても、単に収穫して新しい迷路をスポーンするよりも多くのゴールドは得られません。
これは100%追加の挑戦であり、スキップしても構いません。
追加情報やショートカットが迷路をより速く解くのに役立つ場合にのみ価値があります。

同じ迷路は最大300回解くことができます。これは299回の再配置に相当します。その後は、宝物に奇妙な物質を使用してもゴールドは増えず、`measure()`は`None`を返します。

<spoiler=show hint 1>この問題を解決するための一般的なアプローチは次のとおりです:

迷路を作成し、自分がドローンになったと想像してみてください。

もし自分が迷路の中にいたら、どのように宝物を見つけようとするか考えてみましょう。

あなたの戦略を、他の人が考えずに従えるように、ステップバイステップで書き留めてください。

次に、あなたのステップをコードに翻訳してみてください。
</spoiler>
<spoiler=show hint 2>ループがない限り: すべての壁は実際には1つの大きなつながった壁です。壁に沿って進めば、迷路全体を通り抜けることができます。
このアプローチは非常に少ないコードで済み、すでにどこにいたかを追跡する必要はありません。必要なのは10行程度のコードだけです。</spoiler>
<spoiler=show hint 3>ドローンを東や西のような絶対的な方向に動かす代わりに、「右に曲がる」や「左に曲がる」のような相対的な方向に動かすと非常に便利です。そのためには、ドローンが現在どちらの方向に動いているかを追跡する必要があります。ドローンは実際には回転しませんが、コード内で「仮想的」な回転を保つことができます。
次のインデックスのトリックが役立ちます:

`directions = [North, East, South, West]
index = 0`

`% 4` を使用して、「円を一周」するように回転させ、`West` の後に `North` に戻るようにします。
`# 右に曲がる
index = (index + 1) % 4`

`# 左に曲がる
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=show hint 4>もし解けない場合は、いつでも楽をして、効率の悪い方法でやることができます。
`1`x`1`の迷路を解くのは簡単です。</spoiler>