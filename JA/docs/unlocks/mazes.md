# 迷路
`Items.Weird_Substance`は、植物に[肥料を使うことで得られます](docs/unlocks/fertilizer.md)。このアイテムは茂みに奇妙な効果をもたらします。もしドローンが茂みの上にいて、`use_item(Items.Weird_Substance, amount)`を呼び出すと、茂みは生け垣の迷路に成長します。
迷路のサイズは、使用した`Items.Weird_Substance`の量（`use_item()`呼び出しの第二引数）によって決まります。
迷路のアップグレードがないとき、`n`個の`Items.Weird_Substance`を使うと、`n`x`n`の迷路ができます。迷路のアップグレードレベルごとに宝物が倍になり、それに伴い必要な`Items.Weird_Substance`の量も倍になります。
なので、完全な畑の迷路を作るには：

`plant(Entities.Bush)
n_substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, n_substance)`

なぜかドローンは生け垣の上を飛べません。高く見えないのに不思議です。

生け垣のどこかに宝物が隠されています。`harvest()`をその宝物に使うと、迷路の面積に等しい量のゴールドを受け取れます。（例えば、5x5の迷路では25ゴールドを得ます。）

それ以外の場所で`harvest()`を使うと、迷路は単に消えてしまいます。

ドローンが宝物の上にいる場合、`get_entity_type()`は`Entities.Treasure`と等しくなり、迷路の他の場所では`Entities.Hedge`です。

迷路はループを含んでいませんが、迷路を再利用する場合（再利用方法については下記参照）は別です。したがって、ドローンが戻らずに同じ位置に戻ることはありません。

壁があるかどうかを確認するには、壁を通り抜けようとしてみることができます。
`move()`は成功した場合に`True`を返し、そうでない場合は`False`を返します。

宝物への行き方が分からない場合は、ヒント1を見てください。このような問題に対処する方法を示しています。

さらに挑戦したい場合は、宝物に同じ量の`Items.Weird_Substance`をもう一度使うことで迷路を再利用できます。
これは宝物のゴールドを1つの迷路分増加させ、迷路内のランダムな位置に移動させます。

`measure()`を宝物で使用すると、移動後の位置がタプルとして返されます。
`next_x, next_y = measure()`

宝物が移動するたびに、ランダムな壁が迷路から取り除かれるかもしれません。したがって、再利用済みの迷路にはループが含まれる可能性があります。

迷路のループは、戻らずに同じ場所に戻れることを意味するため、問題の難易度を大幅に上げます。
迷路を再利用しても、新しい迷路を収穫して生成するより多くのゴールドは得られません。
これは完全に追加のチャレンジで、スキップしても問題ありません。
追加情報とショートカットが役立つ場合にのみ価値があります。

同じ迷路は最大300回まで解決できます。これは299回の再配置に相当します。その後、宝物に奇妙な物質を使っても、ゴールドは増えなくなり、`measure()`は`None`を返します。

<spoiler=show hint 1>この問題を解決するための一般的なアプローチはこちら：

迷路を作り、あなたがドローンだと想像してください。

もし迷路にいたら、どのようにして宝物を見つけようとするか考えてみてください。

あなたの戦略をステップバイステップで書き留めてください。そうすれば、他の人も考えずにそれをたどれます。

次に、そのステップをコードに翻訳してみましょう。
</spoiler>
<spoiler=show hint 2>ループがない限り、すべての壁は本当に1つの大きな壁に接続されています。壁に沿って進むと、迷路全体を通り抜けることができます。
このアプローチでは非常に少ないコード行数で済み、すでに通った場所を追跡する必要はありません。約10行のコードで十分です。</spoiler>
<spoiler=show hint 3>ドローンを東や西のような絶対的な方向に移動させる代わりに、「右を向く」や「左を向く」のような相対的な方向に移動させるととても便利です。これを行うには、ドローンが現在どちらに進んでいるのかを追跡する必要があります。ドローンは実際には回転しませんが、コード内で「仮想的な」回転を保持することができます。
以下のインデックストリックはこれに役立ちます：

`directions = [North, East, South, West]
index = 0`

`% 4`を使用して「円を回り込む」ように回転させることができますので、`West`の後に`North`に戻ります。
`# turn right
index = (index + 1) % 4`

`# turn left
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=show hint 4>解決できない場合は、もっと簡単にして効率を落としてやることもできます。 `1`x`1`の迷路を解くのは簡単です。</spoiler>