# Лабиринты
`Items.Weird_Substance`, получаемое при [удобрении](docs/unlocks/fertilizer.md) растений, оказывает странный эффект на кусты. Если дрон находится над кустом и вы вызываете `use_item(Items.Weird_Substance, amount)`, куст вырастет в лабиринт из живых изгородей.
Размер лабиринта зависит от количества использованного `Items.Weird_Substance` (второй аргумент вызова `use_item()`).
Без улучшений лабиринта, использование `n` `Items.Weird_Substance` приведёт к созданию лабиринта `n`x`n`. Каждый уровень улучшения лабиринта удваивает сокровище, но также удваивает необходимое количество `Items.Weird_Substance`. 
Итак, чтобы создать лабиринт на всё поле:

`plant(Entities.Bush)
substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, substance)`


По какой-то причине дрон не может перелететь через живые изгороди, хотя они и не выглядят такими уж высокими.

Где-то в изгороди спрятано сокровище. Используйте `harvest()` на сокровище, чтобы получить золото в количестве, равном площади лабиринта. (Например, лабиринт 5x5 даст 25 золота.)

Если вы используете `harvest()` в любом другом месте, лабиринт просто исчезнет.

`get_entity_type()` равно `Entities.Treasure`, если дрон находится над сокровищем, и `Entities.Hedge` во всех остальных местах лабиринта.

Лабиринты не содержат циклов, если только вы не используете лабиринт повторно (см. ниже, как повторно использовать лабиринт). Так что дрон не может снова оказаться в той же позиции, не возвращаясь назад.

Вы можете проверить, есть ли стена, попытавшись пройти сквозь неё. 
`move()` возвращает `True`, если движение удалось, и `False` в противном случае.

Если вы понятия не имеете, как добраться до сокровища, загляните в Подсказку 1. Она показывает, как подойти к подобной проблеме.


Для дополнительного вызова вы также можете повторно использовать лабиринт, применив то же количество `Items.Weird_Substance` к сокровищу снова. 
Это увеличит количество золота в сокровище на стоимость целого лабиринта и переместит его в случайное место в лабиринте.

Использование `measure()` на сокровище возвращает позицию, в которую оно переместится, в виде кортежа (tuple).
`next_x, next_y = measure()`

Каждый раз, когда сокровище перемещается, случайная стена в лабиринте может быть удалена. Таким образом, повторно используемые лабиринты могут содержать циклы.

Обратите внимание, что циклы в лабиринте значительно усложняют задачу, потому что это означает, что вы можете снова попасть в то же место, не двигаясь назад.
Повторное использование лабиринта не даёт больше золота, чем просто сбор урожая и создание нового лабиринта.
Это 100% дополнительное испытание, которое вы можете просто пропустить.
Оно того стоит, только если дополнительная информация и короткие пути помогут вам решить лабиринт быстрее.

Один и тот же лабиринт можно решить максимум 300 раз. Это соответствует 299 перемещениям. После этого использование weird substance на сокровище больше не будет увеличивать в нём золото, а `measure()` вернёт `None`.

<spoiler=показать подсказку 1>Вот общий подход к решению проблемы:

Создайте лабиринт и представьте, что вы — дрон.

Подумайте, как бы вы пытались найти сокровище, если бы были в лабиринте.

Запишите свою стратегию шаг за шагом, чтобы кто-то другой мог следовать ей, не задумываясь.

Теперь попробуйте перевести ваши шаги в код.
</spoiler>
<spoiler=показать подсказку 2>Пока нет циклов: все стены на самом деле являются одной большой соединённой стеной. Если вы будете следовать вдоль стены, она проведёт вас через весь лабиринт.
Этот подход требует очень мало кода, и вам не нужно отслеживать, где вы уже были. Около 10 строк кода — это всё, что вам нужно.</spoiler>
<spoiler=показать подсказку 3>Вместо того чтобы перемещать дрон в абсолютных направлениях, таких как восток или запад, может быть очень полезно перемещать его в относительных направлениях, например, «повернуть направо» или «повернуть налево». Для этого вам нужно отслеживать, в какую сторону дрон движется в данный момент. Дрон на самом деле никогда не поворачивается, но вы всё равно можете поддерживать «виртуальное» вращение в коде.
Следующий трюк с индексами будет полезен для этого:

`directions = [North, East, South, West]
index = 0`

Используйте `% 4`, чтобы позволить ему вращаться «по кругу», так что после `West` он вернётся к `North`.
`# повернуть направо
index = (index + 1) % 4`

`# повернуть налево
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=показать подсказку 4>Если вы не можете решить задачу, вы всегда можете упростить себе жизнь и сделать это менее эффективно. 
Решить лабиринт `1`x`1` очень просто.</spoiler>