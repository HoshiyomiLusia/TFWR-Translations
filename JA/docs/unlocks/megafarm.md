# メガファーム
この超強力なアンロックで、複数のドローンが使えるようになります。

以前と同じように、最初はドローン1体でスタートします。追加のドローンはまずスポーンさせる必要があり、プログラムが終了すると消えてしまいます。
各ドローンは、それぞれ別のプログラムを実行します。新しいドローンは`spawn_drone(function)`関数を使ってスポーンできます。

`def drone_function():
    move(North)
    do_a_flip()

spawn_drone(drone_function)`

これは`spawn_drone(function)`コマンドを実行したドローンと同じ位置に、新しいドローンをスポーンします。新しいドローンは、指定された関数の実行を開始します。完了すると、自動的に消えます。

ドローン同士は衝突しません。

`max_drones()`を使うと、スポーンできるドローンの最大数を取得できます。
`num_drones()`を使うと、すでに農場にいるドローンの数を取得できます。


## 例:
`def harvest_column():
    for _ in range(get_world_size()):
        harvest()
        move(North)

while True:
    if spawn_drone(harvest_column):
        move(East)`

これにより、最初のドローンは水平に移動しながらさらにドローンをスポーンします。スポーンされたドローンは垂直に移動し、通り道にあるものすべてを収穫します。

利用可能なすべてのドローンがすでにスポーンされている場合、`spawn_drone()`は何もしないで`None`を返します。

<spoiler=ヒントを表示> この超便利な並列`for_all`関数をチェックしてみてください。これは任意の関数を受け取り、農場のすべてのタイルで実行します。そのために利用可能なすべてのドローンを使います。

`def for_all(f):
	def row():
		for _ in range(get_world_size()-1):
			f()
			move(East)
		f()
	for _ in range(get_world_size()):
		if not spawn_drone(row):
			row()
		move(North)

for_all(harvest)`

特に便利なパターンの一つは、ドローンが利用可能ならスポーンし、そうでなければ自分でやることです。

`if not spawn_drone(task):
	task()`
</spoiler>

## 他のドローンの待機
`wait_for(drone)`関数を使うと、他のドローンが終了するのを待つことができます。ドローンをスポーンする際に、その`drone`のハンドルを受け取ります。
`wait_for(drone)`は、他のドローンが実行していた関数の戻り値を返します。

`def get_entity_type_in_direction(dir):
    move(dir)
    return get_entity_type()

def zero_arg_wrapper():
    return get_entity_type_in_direction(North)
drone = spawn_drone(zero_arg_wrapper)
print(wait_for(drone))`

ドローンのスポーンには時間がかかるので、ちょっとしたことのために毎回新しいドローンをスポーンするのは良い考えではありません。

## 共有メモリなし
各ドローンは独自のメモリを持っており、他のドローンのグローバル変数を直接読み書きすることはできません。

`x = 0

def increment():
    global x
    x += 1

wait_for(spawn_drone(increment))
print(x)`

これは`0`を表示します。なぜなら、新しいドローンはグローバル変数`x`の独自のコピーをインクリメントしただけで、最初のドローンの`x`には影響しないからです。

## 競合状態
複数のドローンが同時に同じ農地のタイルに作用することがあります。もし2体のドローンが同じtickの間に同じタイルに作用した場合、両方の作用が発生しますが、その順序によって結果が異なる場合があります。

例えば、ドローン`0`と`1`が、両方とももうすぐ完全に成長する同じ木の上にいると想像してみてください。
ドローン`0`が呼び出す
`use_item(Items.Fertilizer)`
ドローン`1`が呼び出す
`harvest()`

これらのアクションが同時に発生した場合、木はまず肥料を与えられ、次に収穫されます。その場合、木材が手に入ります。しかし、もしドローン`1`がわずかに速かった場合、木は肥料を与えられる前に収穫されてしまい、木材は手に入りません。
これは「競合状態（race condition）」と呼ばれます。これは並列プログラミングでよくある問題で、結果が操作の実行順序に依存してしまいます。

複数のドローンが同じ位置で同時に同じコードを実行した場合に起こりうる、もう一つの問題のある状況です。
`if get_water() < 0.5:
    use_item(Items.Water)`

もし複数のドローンがこれを同時に実行すると、すべてのドローンが最初の行を実行し、`if`ブロックに入ります。そして、すべてのドローンが水を使ってしまい、多くの水を無駄にしてしまいます。
あるドローンが2行目に到達する頃には、その間に別のドローンがタイルに水やりをしたため、`get_water()`はもはや`0.5`未満ではないかもしれません。