# Импорт
Хранить весь код в одном файле быстро становится неудобно. 
Инструкция `import` позволяет импортировать функции и глобальные переменные из другого файла.
Как это работает на одном скриншоте:
![](ImportsInOnePicture400)

Здесь `import module2` выполняет файл с именем `module2` и даёт вам доступ ко всем его глобальным переменным.
Затем вы можете получить доступ к переменным и функциям внутри импортированного модуля, используя оператор `.`.
Так, в этом примере, `module2.print_x()` вызывает `print_x()` из `module2`.

### Дальше читать необязательно

Вы также можете перенести глобальные переменные из импортированного модуля в текущую область видимости, где выполняется инструкция импорта, используя синтаксис `from`.

`from module2 import print_x
print_x()`
Импортирует только указанные глобальные переменные из `module2`.

или

`from module2 import *
print_x()`
Импортирует все глобальные переменные из `module2`.

Это также импортирует файл `module2`, но вместо доступа к нему через переменную с именем `module2`, он распаковывает глобальные переменные из `module2` и присваивает их непосредственно в локальной области видимости.

Эта форма импорта обычно не рекомендуется, потому что она плохо работает, когда два файла импортируют друг друга, и вы можете случайно перезаписать переменные в импортирующем файле из-за совпадения имён. Безопаснее избегать синтаксиса `from`, если вы не уверены в своих действиях.

# Как это работает на самом деле

## TLDR
Импорты могут быть довольно неочевидными, но большинство проблем можно избежать, придерживаясь синтаксиса `import file` вместо `from file import`, и оборачивая всё, что не является определением глобальной переменной, в
`if __name__ == "__main__":`

## Побочные эффекты импорта
Когда вы импортируете файл в первый раз, он выполняет весь файл целиком, а затем даёт вам доступ ко всем переменным, которые были определены во время выполнения.
Если вы импортируете тот же файл снова, он просто вернёт кешированный модуль с первого раза.

Это означает, что инструкции импорта могут иметь побочные эффекты. Если вы импортируете файл, который вызывает `harvest()`, он действительно соберёт урожай во время импорта. Но когда вы импортируете его снова, он не будет собирать урожай, потому что файл выполняется только один раз.

Есть способ избежать таких побочных эффектов, используя переменную `__name__`. Это переменная, которой автоматически присваивается значение `"__main__"`, когда файл запускается напрямую, и имя файла, когда он запускается через `import`.
Считается хорошей практикой помещать любой код, который вы не хотите выполнять при импорте файла, внутрь блока `if __name__ == "__main__":`.

Распространённая структура файла в Python — помещать код, который должен выполняться при запуске файла, в функцию `main()`. Таким образом, вы получаете чёткое различие между локальными переменными (определёнными внутри `main()`) и глобальными переменными, которые можно импортировать (определёнными вне `main()`).

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # do things

if __name__ == "__main__":
    main()`

## Циклические импорты
Что произойдёт, если файл `a` импортирует файл `b`, а файл `b` импортирует файл `a`?

файл `a`:
`import b
x = 0`

файл `b`:
`import a
def f():
    print(a.x)`

Это сработает нормально. Допустим, ни один из двух файлов ещё не загружен, и кто-то выполняет `import a`.

-`a` выполняется до строки `import b`.
-`b` выполняется до строки `import a`.
-Модуль `a` уже существует, но не содержит `x`, потому что он дошёл только до строки `import b`.
-`b` сохраняет ссылку на наполовину загруженный модуль `a` в переменной с именем `a`.
-`b` выполняет инструкцию `def` и сохраняет функцию `f()`.
-`a` продолжает выполняться и инициализирует `x`.

Когда кто-то вызовет `b.f()`, он правильно выведет `0`, потому что модуль `a`, на который у `b` есть ссылка, теперь полностью загружен.

Теперь рассмотрим тот же код с использованием синтаксиса `from`.

файл `a`:
`from b import *
x = 0`

файл `b`:
`from a import *
def f():
    print(x)`

-`a` выполняется до строки `from b import *`.
-`b` выполняется до строки `from a import *`.
-Модуль `a` уже существует, но ещё не был выполнен полностью.
-`b` распаковывает всё, что в данный момент есть в `a`, в свою собственную глобальную область видимости. На данный момент `a` ничего не содержит, потому что он ещё не дошёл до строки `x = 0`, поэтому ничего не импортируется.
-`b` выполняет инструкцию `def` и сохраняет функцию `f()`.
-`a` продолжает выполняться и инициализирует `x`.

Если кто-то теперь вызовет `b.f()`, он получит ошибку, что `x` не существует в текущей области видимости. Это потому, что на этот раз у `b` нет ссылки на всё ещё загружающийся `a`, и он не видит определений, которые были добавлены после импорта.