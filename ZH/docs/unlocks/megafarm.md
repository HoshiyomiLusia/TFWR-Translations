# 超级农场
这个极其强大的解锁项会显著增加农场大小，并让你能使用多架无人机。

为了让事情更简单，你每增加一架新无人机，总会得到正好36个新地块。无人机与地块的比例保持不变。

## 多架无人机
和以前一样，你仍然只从一架无人机开始。额外的无人机必须先被生成，并且在程序终止后会消失。
每架无人机都运行自己独立的程序实例。无人机可以使用以下命令生成新的无人机：
`new_drone_id = spawn_drone("filename")`

这会在运行 `spawn_drone("filename")` 命令的无人机相同位置生成一架新无人机。新无人机将开始执行名为 `filename` 的文件中的程序，所以请用你想要运行的文件名替换 `"filename"`。

你可以把这想象成你告诉你的无人机去名为 `filename` 的文件，然后为下一架无人机按下执行按钮。

无人机之间不会相互碰撞。

使用 `max_drones()` 来获取可以生成的最大无人机数量。
使用 `num_drones()` 来获取农场上已有的无人机数量。
使用 `get_drone_id()` 来找出是哪架无人机在运行代码。

示例：

在一个名为 `farming routine` 的文件中：
`if get_drone_id() == 0:
    # 只有第一架无人机会运行此代码
    while num_drones() < max_drones():
        spawn_drone("farming routine")
        move(East)

while True:
    if can_harvest():
        harvest()
    move(North)`

这将导致你的第一架无人机水平移动并生成更多无人机。生成的无人机随后将垂直移动并收获其路径上的一切。

<spoiler=显示提示>
使用多架无人机最简单的方法是在它们之间划分你的农场。升级项的设计使得每架无人机总能拥有一个 6x6 的田地。
</spoiler>

以下内容相当高级，对于基础的耕作不是必需的

## 竞争条件
多架无人机可以同时与同一个农场地块互动。如果两架无人机在完全相同的 tick 与同一个地块互动，无人机 ID 较低的无人机的动作将首先发生。

例如，想象无人机 `0` 和 `1` 都在同一棵几乎完全长成的树上。
无人机 `0` 调用
`use_item(Items.Fertilizer)`
无人机 `1` 调用
`harvest()`

如果这些动作同时发生，树将首先被施肥然后被收获。在这种情况下，你将从中获得木材。但是，如果无人机 `1` 稍快一些，树将在施肥前被收获，你就不会获得木材。
这被称为“竞争条件”。这是并行编程中的一个常见问题，即结果取决于操作执行的顺序。

当多架无人机在同一位置同时运行相同代码时，可能会发生另一个问题情况。
`if get_water() < 0.5:
    use_item(Items.Water)`

如果多架无人机同时运行这段代码，它们都将运行第一行，这会将它们放入 `if` 代码块中。然后，它们都会使用水，从而浪费大量的水。
当一架无人机到达第二行时，`get_water()` 可能已经不再小于 `0.5`，因为另一架无人机在此期间已经给地块浇了水。

## 无人机通信
如果你对更高级的策略感兴趣，你可能希望你的无人机使用消息传递函数相互通信。

向另一架无人机发送任何值：
`send(data, receiver_drone_id)`

接收任何无人机发送的下一个值：
`data = receive()`

接收特定无人机发送的下一个值：
`data = receive(sender_drone_id)`

`send()` 的执行时间取决于发送数据的大小。例如，发送一个大的 dictionary 需要复制，这可能需要一些时间。

`receive()` 不会等待消息到达。如果还没有发送任何消息，它将返回 `None`。

你可以像这样构建一个等待消息的函数：
`def blocking_receive(sender_drone_id = -1):
    while True:
        data = receive(sender_drone_id)
        if data != None:
            return data`

传递消息的一个有用应用是拥有一个函数，该函数生成一架无人机并向其发送一个要执行的函数。
在一个名为 `drone_spawning` 的文件中：
`def run_on_new_drone(f):
    id = spawn_drone("drone_spawning")
    send(f, id)

if __name__ == "__main__":
    f = blocking_receive()
    f()`

像那样发送函数可能非常慢，因为函数所有捕获的状态，包括所有全局变量，都必须被复制。