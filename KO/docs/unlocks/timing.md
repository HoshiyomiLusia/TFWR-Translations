# 타이밍
정말로 방법을 최적화하고 싶다면 이 게임에서 시간이 어떻게 측정되는지 이해해야 합니다. 이 해금은 바로 그것에 관한 것입니다.

## 새로운 함수
무언가가 얼마나 오래 걸리는지 측정하는 데 유용한 두 가지 함수가 있습니다:

`get_time()`은 게임 시작 후 경과 시간을 초 단위로 반환합니다.

`get_tick_count()`는 실행 시작 후 수행된 tick의 수를 반환합니다.

이 두 함수와 `quick_print()`는 완전히 무료입니다. 호출 작업조차 무료입니다.

## 런타임 세부 정보

### 참고
이것은 실제 세계에서 성능이 작동하는 방식이 아닙니다. 이것들은 일관되고 이해하기 쉬운 타이밍 모델을 갖기 위해 이 게임을 위해 만들어진 규칙일 뿐입니다.
코드를 극한으로 최적화하고 싶을 때만 이 부분에 신경 쓸 것입니다.


코드 실행 시간의 기본 단위는 "tick"이라고 합니다. 속도 업그레이드와 파워가 없으면, 실행은 초당 `400` tick의 속도로 진행됩니다.

일반적으로 `+, -, *, /, //, %, and, or, ...`와 같이 두 값을 결합하는 연산은 실행하는 데 1 tick이 걸립니다.
단일 값 `-`와 `not`은 무료입니다.
`if` 분기 또한 (조건 표현식을 평가하는 데 걸리는 시간 외에) 실행하는 데 1 tick이 걸립니다.
함수 호출과 변수 읽기/쓰기는 무료이지만, 함수 정의는 1 tick이 걸립니다.
`import` 문은 무료입니다.
`.` 연산자로 import된 모듈에 접근하는 것은 무료입니다.
함수나 모듈이 인자나 변수 할당을 통해 전달된 경우, 그것을 사용하면 0 대신 1 tick의 비용이 듭니다.
`for`와 `while` 루프는 시작하는 데 1 tick이 걸리지만, 반복 자체는 무료입니다 (조건/시퀀스 표현식을 평가하는 시간은 제외).
`return`, `break`, `continue`는 모두 무료입니다.
`pass`는 1 tick이 걸리므로 정확한 지연을 만드는 데 사용할 수 있습니다.
데이터 구조를 인덱싱하는 것은 인덱스 연산자에 1 tick이 걸리고, dictionary나 set의 경우 key 크기에 따라 추가적인 tick이 걸립니다.

내장 함수가 실행하는 데 걸리는 tick의 수는 각 함수의 문서에 개별적으로 기록되어 있습니다.