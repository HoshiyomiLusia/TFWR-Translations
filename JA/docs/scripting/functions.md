# 関数
`def`キーワードを使って新しい関数を定義します:
`def f(arg1, arg2 = False):
	#function code`

`()`呼び出し演算子を使って関数を呼び出すことができます:
`f(42)`

また、関数内のローカル変数とグローバル変数については、[Scopes](docs/scripting/scopes.md)を参照してください。

## はじめに
あなたはすでに`harvest()`のような組み込み関数を見てきました。
独自の関数を定義することもでき、それによってコードをモジュール化して構成できます。基本的には、コードのブロックに名前を付けて、好きな場所から呼び出せるようにするものです。

## 関数の定義
例えば、ドローンを複数回移動させる関数を定義することができます。

`def move_n_dir(n, dir):
	for i in range(n):
		move(dir)`

`def`キーワードは、これが関数定義であることを示します。
`move_n_dir`は、関数が割り当てられる名前です。これは任意の有効な変数名であり、関数を呼び出すために使用されます。
`n`と`dir`はパラメータです。これらは関数に渡される値を保持する変数です（これらの値は引数とも呼ばれます）。関数定義には好きなだけパラメータを追加できます。
`:`の後には、関数が呼び出されたときに実行されるコードブロックが続きます。

上記の定義により、次のコードはドローンを`North`に`10`タイル、`West`に`2`タイル移動させます。

`move_n_dir(10, North)
move_n_dir(2, West)`

`def function():`を見たとき、実際には次のような変数代入だと考えるべきです:
`function = create_new_function_object()`
すべての代入と同様に、割り当てられる前に変数を使用することはできません！
`def`ステートメントは、関数呼び出しの前に実行される必要があります。
このコードはerrorをスローします:

`func()
def func():
	pass`

## 戻り値
`return`キーワードを使って、関数に値を返させます。
例えば、次の関数は排他的論理和（XOR）の操作を定義します。排他的論理和は、一方の値が`True`で他方が`False`の場合に`True`を返します:

`def xor(a, b):
	return a != b

if xor(True, False):
	do_a_flip()`

[タプル](docs/scripting/tuples.md)を使うと複数の値を返すことができます。

## デフォルト引数
引数が渡されなかった場合に使用されるデフォルト値を割り当てることもできます。

`def f(a = False):
	if a:
		do_a_flip()

f()

f(True)`

デフォルト値を持つ引数の後に、デフォルト値を持たない引数を続けることはできません。

## 高度な関数の使い方
関数は他の値と同様に値であり、`def`ステートメントは代入ステートメントのように機能し、関数に付けた名前に割り当てます。
これにより、次のようなことが可能になります:

`def f():
	def d():
		do_a_flip()
	return d

f()()`

ここで`f()`は関数`f`を呼び出し、`f`は新しい関数`d`を定義して返します。2番目の`()`は返された関数を実行し、フリップを実行します。
(何が起こっているのか分かりにくいため、このようなことをするのは通常良い考えではありません)

他の関数を引数として受け取る関数を使えば、非常に創造的になれます:

`def f(g, arg):
	for _ in range(10):
		g(arg)

f(move, North)
f(use_item, Items.Fertilizer)`

このコードはドローンを`North`に10回移動させ、その後肥料を10回使用します。