# Мегаферма
Это невероятно мощное улучшение даёт вам доступ к нескольким дронам. 

Как и раньше, вы начинаете всего с одним дроном. Дополнительных дронов нужно сначала запустить, и они исчезнут после завершения программы.
Каждый дрон выполняет свою собственную отдельную программу. Новых дронов можно запускать с помощью функции `spawn_drone(function)`.

`def drone_function():
    move(North)
    do_a_flip()

spawn_drone(drone_function)`

Это запускает нового дрона на той же позиции, что и дрон, выполнивший команду `spawn_drone(function)`. Новый дрон затем начинает выполнять указанную функцию. После завершения он автоматически исчезнет.

Дроны не сталкиваются друг с другом. 

Используйте `max_drones()`, чтобы получить максимальное количество дронов, которое можно запустить.
Используйте `num_drones()`, чтобы получить количество дронов, которые уже находятся на ферме.


## Пример:
`def harvest_column():
    for _ in range(get_world_size()):
        harvest()
        move(North)

while True:
    if spawn_drone(harvest_column):
        move(East)`

Это заставит вашего первого дрона двигаться горизонтально и запускать новых дронов. Запущенные дроны затем будут двигаться вертикально и собирать всё на своём пути.

Если все доступные дроны уже запущены, `spawn_drone()` ничего не сделает и вернёт `None`.

<spoiler=показать подсказку> Посмотрите на эту суперполезную параллельную функцию `for_all`, которая принимает любую функцию и запускает её на каждой клетке фермы. Для этого она использует всех доступных дронов.

`def for_all(f):
	def row():
		for _ in range(get_world_size()-1):
			f()
			move(East)
		f()
	for _ in range(get_world_size()):
		if not spawn_drone(row):
			row()
		move(North)

for_all(harvest)`

Особенно полезный паттерн — запускать дрона, если он доступен, а иначе делать работу самому.

`if not spawn_drone(task):
	task()`
</spoiler>

## Ожидание другого дрона
Используйте функцию `wait_for(drone)`, чтобы дождаться завершения работы другого дрона. Вы получаете идентификатор (`handle`) `drone` при его запуске.
`wait_for(drone)` возвращает значение, которое вернула функция, выполнявшаяся другим дроном.

`def get_entity_type_in_direction(dir):
    move(dir)
    return get_entity_type()

def zero_arg_wrapper():
    return get_entity_type_in_direction(North)
drone = spawn_drone(zero_arg_wrapper)
print(wait_for(drone))`

Обратите внимание, что запуск дронов занимает время, поэтому не стоит запускать нового дрона для каждой мелочи.

## Нет общей памяти
У каждого дрона своя собственная память, и он не может напрямую читать или записывать глобальные переменные другого дрона.

`x = 0

def increment():
    global x
    x += 1

wait_for(spawn_drone(increment))
print(x)`

Это выведет `0`, потому что новый дрон увеличил свою собственную копию глобальной переменной `x`, что не влияет на `x` первого дрона.

## Состояния гонки
Несколько дронов могут взаимодействовать с одной и той же клеткой фермы одновременно. Если два дрона взаимодействуют с одной клеткой в течение одного tick, оба взаимодействия произойдут, но результаты могут отличаться в зависимости от порядка взаимодействий.

Например, представьте, что дроны `0` и `1` оба находятся над одним и тем же почти выросшим деревом.
Дрон `0` вызывает
`use_item(Items.Fertilizer)`
Дрон `1` вызывает
`harvest()`

Если эти действия произойдут одновременно, дерево сначала будет удобрено, а затем собрано. В этом случае вы получите с него древесину. Однако, если дрон `1` окажется немного быстрее, дерево будет собрано до того, как его удобрят, и вы не получите древесину.
Это называется «состояние гонки». Это распространённая проблема в параллельном программировании, когда результат зависит от порядка выполнения операций.

Вот ещё одна проблемная ситуация, которая может возникнуть, когда несколько дронов выполняют один и тот же код одновременно на одной и той же позиции.
`if get_water() < 0.5:
    use_item(Items.Water)`

Если несколько дронов запустят это одновременно, все они выполнят первую строку, что поместит их в блок `if`. Затем все они используют воду, потратив её впустую.
К тому времени, как дрон дойдёт до второй строки, `get_water()` может быть уже не меньше `0.5`, потому что другой дрон тем временем уже полил эту клетку.