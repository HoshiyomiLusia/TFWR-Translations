# Мегаферма
Это невероятно мощное улучшение значительно увеличивает размер фермы и даёт вам доступ к нескольким дронам. 

Чтобы упростить задачу, вы всегда получаете ровно 36 новых клеток для каждого нового дрона. Соотношение дронов к клеткам остаётся постоянным.

## Несколько дронов
Как и раньше, вы начинаете всего с одним дроном. Дополнительные дроны должны быть сначала созданы и исчезнут после завершения программы.
Каждый дрон запускает свой собственный отдельный экземпляр программы. Дроны могут создавать новых дронов, используя
`new_drone_id = spawn_drone("filename")`

Это создаёт нового дрона на той же позиции, что и дрон, выполнивший команду `spawn_drone("filename")`. Новый дрон начнёт выполнять программу из файла с именем `filename`, так что замените `"filename"` на имя файла, который вы хотите запустить.

Вы можете думать об этом так, как будто вы сказали своему дрону перейти к файлу с именем `filename` и нажать кнопку выполнения для следующего дрона.

Дроны не сталкиваются друг с другом. 

Используйте `max_drones()`, чтобы получить максимальное количество дронов, которые можно создать.
Используйте `num_drones()`, чтобы получить количество дронов, которые уже на ферме.
Используйте `get_drone_id()`, чтобы узнать, какой дрон выполняет код.

Пример:

В файле с именем `farming routine`:
`if get_drone_id() == 0:
    # Только первый дрон выполнит это
    while num_drones() < max_drones():
        spawn_drone("farming routine")
        move(East)

while True:
    if can_harvest():
        harvest()
    move(North)`

Это заставит вашего первого дрона двигаться горизонтально и создавать новых дронов. Созданные дроны затем будут двигаться вертикально и собирать всё на своём пути.

<spoiler=показать подсказку>
Самый простой способ использовать несколько дронов — это разделить ферму между ними. Улучшения спроектированы так, что каждый дрон всегда может иметь поле 6x6.
</spoiler>

Всё, что ниже, довольно продвинуто и не требуется для базового фермерства

## Состояния гонки
Несколько дронов могут взаимодействовать с одной и той же клеткой фермы одновременно. Если два дрона взаимодействуют с одной и той же клеткой в один и тот же tick, действие дрона с меньшим ID произойдёт первым.

Например, представьте, что дроны `0` и `1` оба находятся над одним и тем же почти полностью выросшим деревом.
Дрон `0` вызывает
`use_item(Items.Fertilizer)`
Дрон `1` вызывает
`harvest()`

Если эти действия происходят одновременно, дерево сначала будет удобрено, а затем срублено. В этом случае вы получите древесину. Однако, если дрон `1` немного быстрее, дерево будет срублено до того, как его удобрили, и вы не получите древесину.
Это называется "состояние гонки". Это распространённая проблема в параллельном программировании, где результат зависит от порядка выполнения операций.

Вот ещё одна проблемная ситуация, которая может произойти, когда несколько дронов выполняют один и тот же код одновременно на одной и той же позиции.
`if get_water() < 0.5:
    use_item(Items.Water)`

Если несколько дронов запустят это одновременно, они все выполнят первую строку, что поместит их в блок `if`. Затем они все используют воду, тратя её впустую.
К тому времени, как дрон достигнет второй строки, `get_water()` может уже не быть меньше `0.5`, потому что другой дрон уже полил эту клетку.

## Связь между дронами
Если вас интересуют более продвинутые стратегии, вы можете захотеть, чтобы ваши дроны общались друг с другом с помощью функций передачи сообщений.

Отправить любое значение другому дрону:
`send(data, receiver_drone_id)`

Получить следующее значение, отправленное любым дроном:
`data = receive()`

Получить следующее значение, отправленное определённым дроном:
`data = receive(sender_drone_id)`

Время выполнения `send()` зависит от размера отправляемых данных. Например, отправка большого dict требует копирования, что может занять некоторое время.

`receive()` не ждёт прибытия сообщения. Если сообщение ещё не было отправлено, она вернёт `None`.

Вы можете создать функцию, которая ждёт сообщения, вот так:
`def blocking_receive(sender_drone_id = -1):
    while True:
        data = receive(sender_drone_id)
        if data != None:
            return data`

Одно из полезных применений передачи сообщений — это иметь функцию, которая создаёт дрон и отправляет ему функцию для выполнения.
В файле с именем `drone_spawning`:
`def run_on_new_drone(f):
    id = spawn_drone("drone_spawning")
    send(f, id)

if __name__ == "__main__":
    f = blocking_receive()
    f()`

Отправка функций таким образом может быть очень медленной, потому что всё захваченное состояние функции, включая все глобальные переменные, должно быть скопировано.
