# 迷路
植物を[施肥](docs/unlocks/fertilizer.md)することで得られる`Items.Weird_Substance`は、茂みに奇妙な効果をもたらします。ドローンが茂みの上にいるときに`use_item(Items.Weird_Substance, amount)`を呼び出すと、茂みは生垣の迷路に成長します。
迷路のサイズは、使用される`Items.Weird_Substance`の量（`use_item()`呼び出しの2番目の引数）に依存します。
迷路のアップグレードなしでは、`n`個の`Items.Weird_Substance`を使用すると、`n`x`n`の迷路になります。各迷路アップグレードレベルは宝物を2倍にしますが、必要な`Items.Weird_Substance`の量も2倍になります。
したがって、フィールドいっぱいの迷路を作るには:

`plant(Entities.Bush)
n_substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, n_substance)`


どういうわけか、ドローンはそれほど高そうに見えない生垣の上を飛ぶことができません。

生垣のどこかに宝物が隠されています。宝物に対して`harvest()`を使用すると、迷路の面積に等しいゴールドを受け取ります。（例えば、5x5の迷路は25ゴールドを産出します。）

他の場所で`harvest()`を使用すると、迷路は単に消えてしまいます。

`get_entity_type()`は、ドローンが宝物の上にある場合は`Entities.Treasure`に、迷路の他の場所では`Entities.Hedge`に等しくなります。

迷路にはループが含まれていません（迷路を再利用する場合を除く。迷路の再利用方法については以下を参照）。したがって、ドローンが戻ることなく同じ位置に再びたどり着く方法はありません。

壁があるかどうかは、そこを通り抜けようとすることで確認できます。
`move()`は成功した場合は`True`を、失敗した場合は`False`を返します。

宝物への行き方がわからない場合は、ヒント1を見てください。このような問題にどうアプローチするかが示されています。


さらなる挑戦として、宝物に対して同じ量の`Items.Weird_Substance`を再び使用することで、迷路を再利用することもできます。
これにより、宝物の中のゴールドが迷路1つ分増え、迷路内のランダムな位置に移動します。

宝物に対して`measure()`を使用すると、移動先の位置がタプルとして返されます。
`next_x, next_y = measure()`

宝物が移動するたびに、迷路からランダムな壁が取り除かれることがあります。そのため、再利用された迷路にはループが含まれることがあります。

迷路にループがあると、戻ることなく同じ場所に再びたどり着けるため、はるかに難しくなることに注意してください。
迷路を再利用しても、収穫して新しい迷路をスポーンするよりも多くのゴールドが得られるわけではありません。
これは100%追加の挑戦であり、スキップしても構いません。
追加情報とショートカットが迷路をより速く解くのに役立つ場合にのみ価値があります。

同じ迷路は最大300回解くことができます。これは299回の再配置に相当します。その後は、宝物に奇妙な物質を使用してもゴールドは増えず、`measure()`は`None`を返します。

<spoiler=ヒント1を表示>問題解決の一般的なアプローチは次のとおりです:

迷路を作成し、自分がドローンになったと想像してください。

もし自分が迷路の中にいたら、どうやって宝物を見つけるか考えてみてください。

あなたの戦略を、他の誰かが考えずに従えるように、一歩一歩書き出してください。

次に、あなたのステップをコードに翻訳してみてください。
</spoiler>
<spoiler=ヒント2を表示>ループがない限り、すべての壁は実際には一つの大きなつながった壁です。壁に沿って進めば、迷路全体を通り抜けることができます。
このアプローチは非常に少ないコードで済み、どこをすでに通ったかを記録する必要はありません。約10行のコードで十分です。</spoiler>
<spoiler=ヒント3を表示>ドローンを東や西のような絶対的な方向に動かす代わりに、「右に曲がる」や「左に曲がる」のような相対的な方向に動かすと非常に便利です。これを行うには、ドローンが現在どちらの方向を向いているかを記録する必要があります。ドローンは実際には回転しませんが、コード内で「仮想的」な回転を保持することはできます。
次のインデックスのトリックが役立ちます:

`directions = [North, East, South, West]
index = 0`

`% 4`を使用して、「円の周り」を回転できるようにします。これにより、`West`の後に`North`に戻ります。
`# 右に曲がる
index = (index + 1) % 4`

`# 左に曲がる
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=ヒント4を表示>もし解決できない場合は、いつでも楽をして、効率の悪い方法でやることができます。
`1`x`1`の迷路を解くのは簡単です。</spoiler>