# Мегаферма
Эта невероятно мощная технология даёт вам доступ к нескольким дронам. 

Как и раньше, вы всё ещё начинаете с одним дроном. Дополнительные дроны должны быть сначала созданы и исчезнут после завершения программы.
Каждый дрон выполняет свою собственную отдельную программу. Новых дронов можно создавать с помощью функции `spawn_drone(function)`.

`def drone_function():
    move(North)
    do_a_flip()

spawn_drone(drone_function)`

Это создаёт нового дрона на той же позиции, что и дрон, выполнивший команду `spawn_drone(function)`. Новый дрон затем начинает выполнять указанную функцию. По завершении он автоматически исчезнет.

Дроны не сталкиваются друг с другом. 

Используйте `max_drones()`, чтобы получить максимальное количество дронов, которое можно создать.
Используйте `num_drones()`, чтобы получить количество дронов, которые уже находятся на ферме.


## Пример:
`def harvest_column():
    for _ in range(get_world_size()):
        harvest()
        move(North)

while True:
    if spawn_drone(harvest_column):
        move(East)`

Это заставит вашего первого дрона двигаться горизонтально и создавать новых дронов. Созданные дроны затем будут двигаться вертикально и собирать всё на своём пути.

Если все доступные дроны уже созданы, `spawn_drone()` ничего не сделает и вернёт `None`.

<spoiler=показать подсказку> Посмотрите на эту суперполезную параллельную функцию `for_all`, которая принимает любую функцию и запускает её на каждой клетке фермы. Она использует все доступные дроны для этого.

`def for_all(f):
	def row():
		for _ in range(get_world_size()-1):
			f()
			move(East)
		f()
	for _ in range(get_world_size()):
		if not spawn_drone(row):
			row()
		move(North)

for_all(harvest)`

Один особенно полезный шаблон — создать дрона, если он доступен, а в противном случае сделать это самому.

`if not spawn_drone(task):
	task()`
</spoiler>

## Ожидание другого дрона
Используйте функцию `wait_for(drone)`, чтобы дождаться завершения работы другого дрона. Вы получаете идентификатор `drone`, когда создаёте дрона.
`wait_for(drone)` возвращает возвращаемое значение функции, которую выполнял другой дрон.

`def get_entity_type_in_direction(dir):
    move(dir)
    return get_entity_type()

def zero_arg_wrapper():
    return get_entity_type_in_direction(North)
drone = spawn_drone(zero_arg_wrapper)
print(wait_for(drone))`

Обратите внимание, что создание дронов занимает время, поэтому не стоит создавать нового дрона для каждой мелочи.

## Нет общей памяти
У каждого дрона своя собственная память, и он не может напрямую читать или записывать глобальные переменные другого дрона.

`x = 0

def increment():
    global x
    x += 1

wait_for(spawn_drone(increment))
print(x)`

Это выведет `0`, потому что новый дрон увеличил свою собственную копию глобальной переменной `x`, что не влияет на `x` первого дрона.

## Состояния гонки
Несколько дронов могут взаимодействовать с одной и той же клеткой фермы одновременно. Если два дрона взаимодействуют с одной и той же клеткой в течение одного тика, оба взаимодействия произойдут, но результаты могут отличаться в зависимости от порядка взаимодействий.

Например, представьте, что дроны `0` и `1` оба находятся над одним и тем же почти полностью выросшим деревом.
Дрон `0` вызывает
`use_item(Items.Fertilizer)`
Дрон `1` вызывает
`harvest()`

Если эти действия происходят одновременно, дерево сначала будет удобрено, а затем собрано. В этом случае вы получите с него древесину. Однако, если Дрон `1` окажется немного быстрее, дерево будет собрано до того, как его удобрили, и вы не получите древесину.
Это называется «состояние гонки». Это распространённая проблема в параллельном программировании, где результат зависит от порядка выполнения операций.

Вот ещё одна проблемная ситуация, которая может возникнуть, когда несколько дронов выполняют один и тот же код одновременно на одной и той же позиции.
`if get_water() < 0.5:
    use_item(Items.Water)`

Если несколько дронов выполнят это одновременно, они все выполнят первую строку, что поместит их в блок `if`. Затем они все используют воду, тратя её впустую. 
К тому времени, как дрон достигнет второй строки, `get_water()` может быть уже не меньше `0.5`, потому что другой дрон тем временем полил эту клетку.