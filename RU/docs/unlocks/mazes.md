# Лабиринты
`Items.Weird_Substance`, полученное при [удобрении](docs/unlocks/fertilizer.md) растений, странным образом влияет на кусты. Если дрон находится над кустом и вы вызовете `use_item(Items.Weird_Substance, amount)`, куст превратится в лабиринт из живых изгородей.
Размер лабиринта зависит от количества используемого `Items.Weird_Substance` (это второй аргумент в вызове `use_item()`).
Без улучшений лабиринта, использование `n` `Items.Weird_Substance` создаёт лабиринт размером `n`x`n`. Каждый уровень улучшения лабиринта удваивает количество сокровищ, но также удваивает количество `Items.Weird_Substance`, необходимого для создания лабиринта.
Так что, чтобы сделать полный лабиринт:

`plant(Entities.Bush)
n_substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, n_substance)`


По какой-то причине дрон не может перелететь через изгороди, хотя они и не выглядят такими высокими.

В кустах лабиринта спрятано сокровище. Используйте `harvest()` на сокровище, чтобы получить золото, равное площади лабиринта. (Например, лабиринт 5x5 даст 25 золота.)

Если использовать `harvest()` в любом другом месте, лабиринт просто исчезнет.

`get_entity_type()` равно `Entities.Treasure`, если дрон находится над сокровищем и `Entities.Hedge` в других местах в лабиринте.

Лабиринты не содержат петель, если только вы не используете лабиринт повторно (см. ниже, как повторно использовать лабиринт). Так что дрон не может оказаться в том же месте без возврата обратно.

Вы можете проверить, есть ли стена, пытаясь пройти через неё. 
`move()` вернёт `True`, если перемещение удалось, и `False` в противном случае.

Если не знаете, как добраться до сокровища, взгляните на Подсказку 1. Она показывает, как подойти к решению подобной задачи.


Для дополнительного испытания вы можете также использовать лабиринт повторно, используя такое же количество `Items.Weird_Substance` вновь на сокровище. 
Это увеличит количество золота в сокровище на одно полное лабиринта и случайным образом переместит его положение внутри лабиринта.

Использование `measure()` на сокровище возвращает позицию, куда оно переместится, в виде кортежа.
`next_x, next_y = measure()`

Каждый раз, когда сокровище перемещается, из лабиринта может быть удалена случайная стенка. Таким образом, повторно используемые лабиринты могут содержать петли.

Учтите, что петли в лабиринте делают его намного сложнее, так как это значит, что вы можете попасть в одно и то же место снова без возврата.
Повторное использование лабиринта не даст больше золота, чем просто собрать и создать новый лабиринт.
Это на 100% дополнительное испытание, которое можно просто пропустить.
Оно оправдано только в том случае, если дополнительная информация и короткие пути помогают быстрее решить лабиринт.

Один и тот же лабиринт можно решить максимум 300 раз. Это соответствует 299 перемещениям. После этого использование странного вещества на сокровище больше не увеличит золото в нем, а `measure()` вернет `None`.

<spoiler=показать подсказку 1>Вот общий подход к решению задачи:

Создайте лабиринт и представьте, что вы - дрон.

Подумайте, как бы вы попытались найти сокровище, если бы оказались в лабиринте.

Пошагово запишите свою стратегию так, чтобы кто-то другой мог следовать ей без раздумий.

Теперь попробуйте перевести ваши шаги в код.
</spoiler>
<spoiler=показать подсказку 2>Пока нет петель: Все стены на самом деле просто одна большая соединенная стена. Если следовать вдоль стены, она проведет вас через весь лабиринт.
Этот метод требует очень мало кода, и вам не нужно отслеживать, где вы уже были. Примерно 10 строк кода - все, что вам нужно.</spoiler>
<spoiler=показать подсказку 3>Вместо того, чтобы двигать дрон в абсолютных направлениях, таких как восток или запад, можно очень полезно двигать его в относительных направлениях, таких как "повернуть направо" или "повернуть налево". Для этого вам нужно отслеживать, в каком направлении дрон движется в данный момент. Дрон никогда на самом деле не поворачивается, но вы всё же можете создать "виртуальное" вращение в коде.
Следующий трюк с индексами будет полезен:

`directions = [North, East, South, West]
index = 0`

Используйте `% 4`, чтобы позволить ему вращаться "по кругу", так что после `West` он вновь обернется в `North`.
`# повернуть направо
index = (index + 1) % 4`

`# повернуть налево
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=показать подсказку 4>Если вы не можете это решить, вы всегда можете облегчить себе задачу и сделать это менее эффективно.
Решение `1`x`1` лабиринта тривиально.</spoiler>