# 메가 팜
이 믿을 수 없을 정도로 강력한 해금은 농장 크기를 크게 늘리고 여러 드론에 접근할 수 있게 해줍니다.

일을 더 쉽게 만들기 위해, 각 새로운 드론에 대해 항상 정확히 36개의 새로운 타일을 받습니다. 드론 대 타일의 비율은 일정하게 유지됩니다.

## 다중 드론
이전과 마찬가지로, 여전히 하나의 드론으로 시작합니다. 추가 드론은 먼저 생성되어야 하며 프로그램이 종료된 후 사라집니다.
각 드론은 자체의 별도 프로그램 인스턴스를 실행합니다. 드론은 다음을 사용하여 새로운 드론을 생성할 수 있습니다
`new_drone_id = spawn_drone("filename")`

이것은 `spawn_drone("filename")` 명령을 실행한 드론과 같은 위치에 새로운 드론을 생성합니다. 새로운 드론은 `filename`이라는 이름의 파일에 있는 프로그램을 실행하기 시작하므로, `"filename"`을 실행하려는 파일의 이름으로 바꾸세요.

이것은 마치 드론에게 `filename`이라는 이름의 파일로 가서 다음 드론을 위해 실행 버튼을 누르라고 말하는 것과 같습니다.

드론은 서로 충돌하지 않습니다.

생성할 수 있는 최대 드론 수를 얻으려면 `max_drones()`를 사용하세요.
농장에 이미 있는 드론 수를 얻으려면 `num_drones()`를 사용하세요.
어떤 드론이 코드를 실행하고 있는지 알아보려면 `get_drone_id()`를 사용하세요.

예시:

`farming routine`이라는 이름의 파일에서:
`if get_drone_id() == 0:
    # 첫 번째 드론만 이것을 실행합니다
    while num_drones() < max_drones():
        spawn_drone("farming routine")
        move(East)

while True:
    if can_harvest():
        harvest()
    move(North)`

이렇게 하면 첫 번째 드론이 수평으로 움직이며 더 많은 드론을 생성합니다. 생성된 드론들은 수직으로 움직이며 경로상의 모든 것을 수확할 것입니다.

<spoiler=힌트 보기>
여러 드론을 사용하는 가장 쉬운 방법은 농장을 그들 사이에 나누는 것입니다. 업그레이드는 각 드론이 항상 6x6 필드를 가질 수 있도록 설계되었습니다.
</spoiler>

여기 아래의 모든 내용은 상당히 고급이며 기본적인 농사에는 필요하지 않습니다

## 레이스 컨디션
여러 드론이 동시에 같은 농장 타일과 상호 작용할 수 있습니다. 두 드론이 정확히 같은 tick에 같은 타일과 상호 작용하면, 드론 ID가 낮은 드론의 행동이 먼저 일어납니다.

예를 들어, 드론 `0`과 `1`이 모두 거의 다 자란 같은 나무 위에 있다고 상상해 보세요.
드론 `0`이 호출합니다
`use_item(Items.Fertilizer)`
드론 `1`이 호출합니다
`harvest()`

이러한 행동이 동시에 발생하면, 나무는 먼저 비료를 받고 그 다음에 수확됩니다. 이 경우, 나무로부터 목재를 받게 됩니다. 그러나 드론 `1`이 약간 더 빠르면, 나무는 비료를 받기 전에 수확될 것이고, 목재를 받지 못할 것입니다.
이것을 "레이스 컨디션(race condition)"이라고 합니다. 이것은 병렬 프로그래밍에서 흔히 발생하는 문제로, 결과가 작업이 수행되는 순서에 따라 달라집니다.

여러 드론이 같은 위치에서 같은 코드를 동시에 실행할 때 발생할 수 있는 또 다른 문제 상황이 있습니다.
`if get_water() < 0.5:
    use_item(Items.Water)`

여러 드론이 이것을 동시에 실행하면, 모두 첫 번째 줄을 실행하여 `if` 블록으로 들어갑니다. 그런 다음, 모두 물을 사용하여 많은 양을 낭비하게 됩니다.
한 드론이 두 번째 줄에 도달할 때쯤이면, 다른 드론이 그 사이에 타일에 물을 주었기 때문에 `get_water()`가 더 이상 `0.5`보다 작지 않을 수 있습니다.

## 드론 통신
더 고급 전략에 관심이 있다면, 메시지 전달 함수를 사용하여 드론들이 서로 통신하게 하고 싶을 수 있습니다.

다른 드론에게 어떤 값이든 보내기:
`send(data, receiver_drone_id)`

어떤 드론이든 보낸 다음 값 받기:
`data = receive()`

특정 드론이 보낸 다음 값 받기:
`data = receive(sender_drone_id)`

`send()`의 실행 시간은 전송되는 데이터의 크기에 따라 다릅니다. 예를 들어, 큰 dictionary를 보내는 것은 복사가 필요하므로 시간이 걸릴 수 있습니다.

`receive()`는 메시지가 도착하기를 기다리지 않습니다. 아직 메시지가 전송되지 않았다면 `None`을 반환합니다.

다음과 같이 메시지를 기다리는 함수를 만들 수 있습니다:
`def blocking_receive(sender_drone_id = -1):
    while True:
        data = receive(sender_drone_id)
        if data != None:
            return data`

메시지 전달의 한 가지 유용한 응용은 드론을 생성하고 실행할 함수를 보내는 함수를 갖는 것입니다.
`drone_spawning`이라는 이름의 파일에서:
`def run_on_new_drone(f):
    id = spawn_drone("drone_spawning")
    send(f, id)

if __name__ == "__main__":
    f = blocking_receive()
    f()`

모든 전역 변수를 포함한 함수의 모든 캡처된 상태를 복사해야 하므로, 그런 식으로 함수를 보내는 것은 매우 느릴 수 있습니다.
