# 迷宫
通过给植物[施肥](docs/unlocks/fertilizer.md)获得的 `Items.Weird_Substance` 对灌木有奇怪的效果。如果无人机在一棵灌木上方，并且你调用了 `use_item(Items.Weird_Substance, amount)`，这棵灌木就会长成一个树篱迷宫。
迷宫的大小取决于所使用的 `Items.Weird_Substance` 的数量（`use_item()` 调用的第二个参数）。
在没有迷宫升级的情况下，使用 `n` 份 `Items.Weird_Substance` 会生成一个 `n`x`n` 的迷宫。每个迷宫升级等级都会使宝藏翻倍，但同时也会使所需的 `Items.Weird_Substance` 数量翻倍。
所以要制作一个铺满整个场地的迷宫：

`plant(Entities.Bush)
substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, substance)`


出于某种原因，无人机无法飞越树篱，尽管它们看起来并不高。

树篱中藏着一个宝藏。对宝藏使用 `harvest()` 可以获得数量等于迷宫面积的黄金。（例如，一个 5x5 的迷宫会产出 25 黄金。）

如果你在其他任何地方使用 `harvest()`，迷宫会直接消失。

如果无人机在宝藏上方，`get_entity_type()` 的值等于 `Entities.Treasure`，在迷宫的其他任何地方则等于 `Entities.Hedge`。

迷宫不包含任何回路，除非你重复使用它（见下文如何重复使用迷宫）。所以无人机不可能在不回头的情况下再次回到相同的位置。

你可以通过尝试移动来检查是否有墙。 
`move()` 成功时返回 `True`，否则返回 `False`。

`can_move()` 可以用来在不移动的情况下检查是否有墙。

如果你不知道如何找到宝藏，可以看看提示1。它会告诉你如何解决这类问题。

在迷宫中的任何地方使用 `measure()` 都会返回宝藏的位置。
`x, y = measure()`

作为一个额外的挑战，你也可以通过在宝藏上再次使用相同数量的 `Items.Weird_Substance` 来重复使用迷宫。
这会将宝藏中的黄金数量增加一整个迷宫的量，并将其移动到迷宫中的一个随机位置。

每次宝藏移动时，迷宫中的一堵随机墙壁可能会被移除。所以重复使用的迷宫可能包含回路。

请注意，迷宫中的回路会让问题变得困难得多，因为这意味着你可以在不回头的情况下再次到达相同的位置。
重复使用迷宫并不会比直接收获并生成一个新迷宫给你带来更多的黄金。
这完全是一个额外的挑战，你可以直接跳过。
只有当额外的信息和捷径能帮助你更快地解决迷宫时，这样做才值得。

同一个迷宫最多可以被解决 300 次。这对应于 299 次重新定位。之后，在宝藏上使用 Weird Substance 将不再增加其中的黄金，并且 `measure()` 将返回 `None`。

<spoiler=显示提示 1>这里有一个解决这个问题的一般方法：

创建一个迷宫，并想象你就是无人机。

想一想如果你在迷宫里，你会如何尝试寻找宝藏。

一步一步地写下你的策略，以便其他人可以不加思考地遵循它。

现在尝试将你的步骤翻译成代码。
</spoiler>
<spoiler=显示提示 2>只要没有回路：所有的墙壁实际上都是一堵巨大的相连的墙。如果你沿着墙走，它会带你走遍整个迷宫。
这种方法需要很少的代码，而且你不需要记录你已经去过的地方。大约10行代码就足够了。</spoiler>
<spoiler=显示提示 3>与其像东或西那样以绝对方向移动无人机，不如以“右转”或“左转”这样的相对方向移动它会非常有用。要做到这一点，你需要记录无人机当前移动的方向。无人机实际上从不旋转，但你仍然可以在代码中保持一个“虚拟”的旋转。
下面的索引技巧对此很有帮助：

`directions = [North, East, South, West]
index = 0`

使用 `% 4` 来让它可以“绕圈”旋转，这样在 `West` 之后它会绕回到 `North`。
`# 右转
index = (index + 1) % 4`

`# 左转
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=显示提示 4>如果你解决不了，你总是可以让自己轻松一点，用效率较低的方式来做。
解决一个 `1`x`1` 的迷宫非常简单。</spoiler>