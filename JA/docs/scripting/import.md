# インポート
すべてのコードを1つのファイルに入れると、すぐに管理が難しくなります。
`import` 文を使うと、別のファイルから関数やグローバル変数をインポートできます。

`import filename`

これが最も単純な形式のインポート文です。これにより、`filename` という名前のファイルで定義されているすべてのものにアクセスできるようになります。ゲーム内の各ウィンドウはファイルであり、ファイル名はウィンドウの上部に表示される名前です。

2つのファイルを使った例です：
helperという名前のファイル：
`x = 0

def say_hello():
    print("hello from helper")`

他のファイル：
`import helper
helper.say_hello()
helper.x += 1`

ここで `import helper` は `helper` という名前のファイルを実行し、そのすべてのグローバル変数にアクセスできるようにします。
インポートされたモジュール内の変数や関数には、`.` 演算子を使ってアクセスできます。
この例では、`helper.say_hello()` がhelper内の `say_hello()` を呼び出し、最後の行でグローバル変数xをインクリメントします。

`from` 構文を使って、インポートされたモジュールから現在のスコープにグローバル変数を移動させることもできます。

`from helper import *`
helperからすべてのグローバル変数をインポートします。

または

`from helper import say_hello`
helperから指定されたグローバル変数のみをインポートします。

これもhelperファイルをインポートしますが、`helper` という名前の変数を通じてアクセスする代わりに、`helper` からグローバル変数をアンパックし、ローカルスコープに直接割り当てます。

`from helper import say_hello
say_hello()`

この形式のインポートは、2つのファイルが互いにインポートし合う場合にうまく機能しないため、通常は推奨されません。また、名前の衝突により、インポート元のファイルで誤って変数を上書きしてしまう可能性があります。

# 実際の仕組み

## TLDR;
インポートは直感的でないことがありますが、ほとんどの問題は `from file import` の代わりに `import file` 構文に固執し、グローバル定義でないものすべてを
`if __name__ == "__main__":`
で囲むことで回避できます。

## インポートの副作用
初めてファイルをインポートすると、ファイル全体が実行され、実行中に定義されたすべての変数にアクセスできるようになります。
同じファイルを再度インポートすると、初回にキャッシュされたモジュールが再度返されるだけです。

これは、インポート文には副作用がある可能性があることを意味します。`harvest()` を呼び出すファイルをインポートすると、インポート中に実際に収穫が行われます。しかし、再度インポートしても、ファイルは一度しか実行されないため、再度収穫されることはありません。

`__name__` 変数を使うことで、このような副作用を避ける方法があります。これは、ファイルが直接実行されたときには自動的に `"__main__"` に設定され、`import` を通じて実行されたときにはファイル名に設定される変数です。
ファイルがインポートされたときに実行したくないコードは、`if __name__ == "__main__":` ブロック内に入れるのが良い習慣とされています。

Pythonで一般的なファイル構造は、ファイルが実行されたときに実行されるべきコードを `main()` 関数に入れることです。これにより、ローカル変数（`main()` 内で定義）とインポート可能なグローバル変数（`main()` 外で定義）を明確に区別できます。

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # 何かをする

if __name__ == "__main__":
    main()`

## インポートサイクル
ファイル `a` がファイル `b` をインポートし、ファイル `b` がファイル `a` をインポートするとどうなるでしょうか？

ファイル `a`:
`import b
x = 0`

ファイル `b`:
`import a
def f():
    print(a.x)`

これは問題なく動作します。どちらのファイルもまだロードされておらず、誰かが `import a` を実行したとしましょう。

- `a` は `import b` の行まで実行されます。
- `b` は `import a` の行まで実行されます。
- モジュール `a` はすでに存在しますが、`import b` の行にしか到達していないため `x` は含まれていません。
- `b` は、半分ロードされたモジュール `a` への参照を `a` という名前の変数に格納します。
- `b` は `def` 文を実行し、関数 `f()` を格納します。
- `a` は実行を続け、`x` を初期化します。

誰かが `b.f()` を呼び出すと、`b` が参照しているモジュール `a` が完全にロードされているため、正しく `0` が表示されます。

次に、`from` 構文を使った同じコードを考えてみましょう。

ファイル `a`:
`from b import *
x = 0`

ファイル `b`:
`from a import *
def f():
    print(x)`

- `a` は `from b import *` の行まで実行されます。
- `b` は `from a import *` の行まで実行されます。
- モジュール `a` はすでに存在しますが、まだ完全には実行されていません。
- `b` は `a` に現在あるものすべてを自身のグローバルスコープにアンパックします。この時点では、`a` は `x = 0` の行に到達していないため何も含まれておらず、何もインポートされません。
- `b` は `def` 文を実行し、関数 `f()` を格納します。
- `a` は実行を続け、`x` を初期化します。

もし誰かが `b.f()` を呼び出すと、現在のスコープに `x` が存在しないというエラーが発生します。これは、今回 `b` がまだロード中の `a` への参照を持っておらず、インポート後に追加された定義を見ていないためです。