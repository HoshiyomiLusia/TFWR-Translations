# Import
把你所有的代码都放在一个文件里很快就会变得难以管理。
`import` 语句允许你从另一个文件导入函数和全局变量。

`import filename`

这是 `import` 语句最简单的形式。它会让你能够访问名为 `filename` 的文件中定义的所有内容。游戏中的每个窗口都是一个文件，文件名是窗口顶部显示的名称。

这里是一个包含两个文件的例子：
名为 helper 的文件：
`x = 0

def say_hello():
    print("hello from helper")`

其他某个文件：
`import helper
helper.say_hello()
helper.x += 1`

这里 `import helper` 会运行名为 `helper` 的文件，并让你能够访问它所有的全局变量。
然后你可以使用 `.` 运算符访问导入模块中的变量和函数。
所以在这个例子中，`helper.say_hello()` 调用了 helper 文件中的 `say_hello()`，最后一行则增加了全局变量 x 的值。

你也可以使用 `from` 语法将导入模块中的全局变量移到执行 import 语句的当前作用域中。

`from helper import *`
从 helper 导入所有全局变量。

或者

`from helper import say_hello`
仅从 helper 导入指定的全局变量。

这也会导入 helper 文件，但不是通过一个名为 `helper` 的变量来访问它，而是将 `helper` 中的全局变量解包并直接赋给本地作用域。

`from helper import say_hello
say_hello()`

这种形式的 import 通常不推荐，因为它在两个文件相互导入时效果不佳，而且你可能会因为命名冲突而意外覆盖导入文件中的变量。

# 它的工作原理

## 简单来说
导入可能相当不直观，但大多数问题都可以通过坚持使用 `import file` 语法而不是 `from file import` 来避免，并将所有不是全局定义的内容包装在
`if __name__ == "__main__":`
中。

## 导入的副作用
第一次导入一个文件时，它会执行整个文件，然后让你能够访问在执行过程中定义的所有变量。
如果你再次导入同一个文件，它只会再次返回第一次缓存的模块。

这意味着 import 语句可能会有副作用。如果你导入一个调用了 `harvest()` 的文件，它实际上会在导入过程中进行收获。但当你再次导入它时，它不会再次收获，因为文件只运行一次。

有一种方法可以使用 `__name__` 变量来避免这种副作用。这是一个变量，当文件被直接运行时，它会自动设置为 `"__main__"`，而当文件通过 `import` 运行时，它会被设置为文件名。
一种好的做法是，将任何你不想在文件被导入时运行的代码放在 `if __name__ == "__main__":` 代码块内。

Python 中一个常见的文件结构是将文件运行时应执行的代码放入一个 `main()` 函数中。这样你就能清楚地区分局部变量（在 `main()` 中定义）和可以被导入的全局变量（在 `main()` 外定义）。

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # 做一些事

if __name__ == "__main__":
    main()`

## 导入循环
如果文件 `a` 导入文件 `b`，而文件 `b` 又导入文件 `a`，会发生什么？

文件 `a`：
`import b
x = 0`

文件 `b`：
`import a
def f():
    print(a.x)`

这会正常工作。假设这两个文件都还没有被加载，然后其他地方执行了 `import a`。

-`a` 运行到 `import b` 这一行。
-`b` 运行到 `import a` 这一行。
-模块 `a` 已经存在，但不包含 `x`，因为它只执行到了 `import b` 这一行。
-`b` 将对半加载的模块 `a` 的引用存储在一个名为 `a` 的变量中。
-`b` 运行 `def` 语句并存储函数 `f()`。
-`a` 继续运行并初始化 `x`。

当有人调用 `b.f()` 时，它会正确打印 `0`，因为 `b` 引用的模块 `a` 现在已经完全加载了。

现在考虑使用 `from` 语法的相同代码。

文件 `a`：
`from b import *
x = 0`

文件 `b`：
`from a import *
def f():
    print(x)`

-`a` 运行到 `from b import *` 这一行。
-`b` 运行到 `from a import *` 这一行。
-模块 `a` 已经存在，但还没有完全执行。
-`b` 将 `a` 中当前存在的所有内容解包到自己的全局作用域中。此时，`a` 什么也不包含，因为它还没有执行到 `x = 0` 这一行，所以什么也没有导入。
-`b` 运行 `def` 语句并存储函数 `f()`。
-`a` 继续运行并初始化 `x`。

如果现在有人调用 `b.f()`，他们会得到一个 `x` 在当前作用域中不存在的错误。这是因为这一次 `b` 没有对仍在加载的 `a` 的引用，也看不到在导入后添加的定义。