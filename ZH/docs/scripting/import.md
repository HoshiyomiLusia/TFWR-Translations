# 导入
把你所有的代码都放在一个文件里，很快就会变得难以管理。
`import` 语句允许你从另一个文件导入函数和全局变量。
一张截图说明它的工作原理：
![](ImportsInOnePicture400)

这里 `import module2` 会运行名为 `module2` 的文件，并让你能访问它所有的全局变量。
然后你可以使用 `.` 运算符来访问导入模块中的变量和函数。
所以在这个例子中，`module2.print_x()` 调用了 `module2` 中的 `print_x()`。

### 无需继续阅读

你也可以使用 `from` 语法，将导入模块中的全局变量移到执行 import 语句的当前作用域中。

`from module2 import print_x
print_x()`
只从 `module2` 导入指定的全局变量。

或者

`from module2 import *
print_x()`
从 `module2` 导入所有全局变量。

这同样会导入 `module2` 文件，但不是通过一个名为 `module2` 的变量来访问它，而是将 `module2` 中的全局变量解包并直接赋给本地作用域。

通常不推荐这种导入形式，因为它在两个文件相互导入时效果不佳，而且你可能会因为命名冲突而意外覆盖导入文件中的变量。如果你不清楚自己在做什么，最好避免使用 `from` 语法。

# 真实工作原理

## 太长不看版
导入可能相当不直观，但大多数问题都可以通过坚持使用 `import file` 语法而不是 `from file import`，并将所有不是全局定义的内容包裹在
`if __name__ == "__main__":`
中来避免。

## 导入的副作用
第一次导入一个文件时，它会执行整个文件，然后让你能访问在执行过程中定义的所有变量。
如果你再次导入同一个文件，它只会再次返回第一次的缓存模块。

这意味着 import 语句可能会有副作用。如果你导入一个调用了 `harvest()` 的文件，它在导入过程中真的会执行收获。但当你再次导入它时，它不会再次收获，因为文件只运行一次。

有一种方法可以使用 `__name__` 变量来避免这种副作用。当一个文件被直接运行时，这个变量会自动设置为 `"__main__"`；当一个文件通过 `import` 运行时，它会被设置为该文件的名字。
一种好的做法是，将任何你不想在文件被导入时运行的代码，都放在一个 `if __name__ == "__main__":` 代码块中。

在 Python 中，一个常见的文件结构是把文件运行时应执行的代码放入一个 `main()` 函数中。这样，你就能清楚地区分局部变量（在 `main()` 内部定义）和可以被导入的全局变量（在 `main()` 外部定义）。

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # 做些事

if __name__ == "__main__":
    main()`

## 导入循环
如果文件 `a` 导入文件 `b`，同时文件 `b` 又导入文件 `a`，会发生什么？

文件 `a`：
`import b
x = 0`

文件 `b`：
`import a
def f():
    print(a.x)`

这样是没问题的。假设这两个文件都还没有被加载，然后其他人执行了 `import a`。

-`a` 运行到 `import b` 这一行。
-`b` 运行到 `import a` 这一行。
-模块 `a` 已经存在，但不包含 `x`，因为它只运行到了 `import b` 这一行。
-`b` 将对加载了一半的模块 `a` 的引用存储在一个名为 `a` 的变量中。
-`b` 运行 `def` 语句并存储函数 `f()`。
-`a` 继续运行并初始化 `x`。

当有人调用 `b.f()` 时，它会正确地打印出 `0`，因为 `b` 所引用的模块 `a` 现在已经完全加载了。

现在考虑使用 `from` 语法的相同代码。

文件 `a`：
`from b import *
x = 0`

文件 `b`：
`from a import *
def f():
    print(x)`

-`a` 运行到 `from b import *` 这一行。
-`b` 运行到 `from a import *` 这一行。
-模块 `a` 已经存在，但还没有被完全执行。
-`b` 将 `a` 中当前存在的所有东西解包到它自己的全局作用域中。此时，`a` 什么也不包含，因为它还没有运行到 `x = 0` 这一行，所以什么也没有被导入。
-`b` 运行 `def` 语句并存储函数 `f()`。
-`a` 继续运行并初始化 `x`。

如果现在有人调用 `b.f()`，他们会得到一个错误，提示 `x` 在当前作用域中不存在。这是因为这一次 `b` 没有一个指向仍在加载中的 `a` 的引用，也看不到在导入之后才添加的定义。