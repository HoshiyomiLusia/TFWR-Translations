# Функции
Используйте ключевое слово `def` для определения новой функции:
`def f(arg1, arg2 = False):
	#код функции`

Вы можете использовать оператор вызова `()` для вызова функции:
`f(42)`

См. также [Области видимости](docs/scripting/scopes.md), чтобы узнать о локальных и глобальных переменных в функциях.

## Введение
Вы уже видели встроенные функции, такие как `harvest()`.
Вы также можете определять свои собственные функции, что позволяет структурировать ваш код модульным образом. По сути, это позволяет вам дать имя блоку кода, чтобы вы могли вызывать его откуда угодно.

## Определение функций
Например, вы могли бы определить функцию, которая перемещает дрон несколько раз.

`def move_n_dir(n, dir):
	for i in range(n):
		move(dir)`

Ключевое слово `def` сигнализирует о том, что это определение функции. 
`move_n_dir` — это имя, к которому привязывается функция. Это может быть любое допустимое имя переменной, и оно будет использоваться для вызова функции.
`n` и `dir` — это параметры. Это переменные, которые содержат значения, передаваемые в функцию (эти значения также называют аргументами). Вы можете добавить столько параметров в определение функции, сколько захотите.
После `:` идёт блок кода, который будет выполняться при вызове функции.

С приведённым выше определением следующий код перемещает дрон на `10` клеток `North` и на `2` клетки `West`.

`move_n_dir(10, North)
move_n_dir(2, West)`

Когда вы видите `def function():`, вы должны воспринимать это как присваивание переменной, вот так:
`function = create_new_function_object()`
Как и при любом присваивании, вы не можете использовать переменную до того, как ей было что-то присвоено!
Инструкция `def` должна быть выполнена до любых вызовов функции.
Этот код вызовет ошибку:

`func()
def func():
	pass`

## Возвращаемые значения
Используйте ключевое слово `return`, чтобы функция вернула значение. 
Например, следующая функция определяет операцию исключающего ИЛИ. Исключающее ИЛИ возвращает `True`, если одно значение `True`, а другое `False`:

`def xor(a, b):
	return a != b

if xor(True, False):
	do_a_flip()`

[Кортежи (tuple)](docs/scripting/tuples.md) позволяют возвращать несколько значений.

## Аргументы по умолчанию
Вы также можете присвоить значения по умолчанию, которые будут использоваться, если аргументы не переданы.

`def f(a = False):
	if a:
		do_a_flip()

f()

f(True)`

Аргумент со значением по умолчанию не может следовать за аргументом, у которого нет значения по умолчанию.

## Продвинутое использование функций
Функции — это такие же значения, как и любые другие, а инструкция `def` просто действует как инструкция присваивания, присваивая функцию тому имени, которое вы ей даёте.
Это позволяет делать такие вещи:

`def f():
	def d():
		do_a_flip()
	return d

f()()`

Здесь `f()` вызывает функцию `f`, которая определяет и возвращает новую функцию `d`. Вторые `()` затем выполняют возвращённую функцию и делают сальто.
(Обычно делать такие вещи — не лучшая идея, потому что сложно понять, что происходит)

Функции, которые принимают другие функции в качестве аргументов, позволяют вам проявить настоящую креативность:

`def f(g, arg):
	for _ in range(10):
		g(arg)

f(move, North)
f(use_item, Items.Fertilizer)`

Этот код перемещает дрон `North` 10 раз, а затем использует удобрение 10 раз.