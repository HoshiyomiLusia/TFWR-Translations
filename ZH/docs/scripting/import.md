# Import (导入)
把所有代码都放在一个文件里很快就会变得难以管理。
`import` 语句允许你从另一个文件导入函数和全局变量。

`import filename`

这是 import 语句最简单的形式。它会让你能够访问到名为 `filename` 的文件中定义的所有内容。游戏中的每个窗口都是一个文件，文件名就是窗口顶部显示的名字。

这里是一个包含两个文件的例子：
名为 helper 的文件：
`x = 0

def say_hello():
    print("hello from helper")`

其他某个文件：
`import helper
helper.say_hello()
helper.x += 1`

这里的 `import helper` 会运行名为 `helper` 的文件，并让你能访问它所有的全局变量。
然后你可以使用 `.` 运算符来访问导入模块中的变量和函数。
所以在这个例子中，`helper.say_hello()` 调用了 helper 里面的 `say_hello()`，最后一行则增加了全局变量 x 的值。

你也可以使用 `from` 语法，将导入模块中的全局变量移到执行 import 语句的当前 scope 中。

`from helper import *`
从 helper 导入所有全局变量。

或

`from helper import say_hello`
只从 helper 导入指定的全局变量。

这也会导入 helper 文件，但它不是通过一个名为 `helper` 的变量来访问，而是从 `helper` 中解包全局变量，并直接在本地 scope 中赋值。

`from helper import say_hello
say_hello()`

这种形式的导入通常不被推荐，因为当两个文件相互导入时，它不能很好地工作，而且你可能会因为命名冲突而意外覆盖导入文件中的变量。

# 它的工作原理

## 太长不看：
导入可能相当不直观，但大多数问题都可以通过坚持使用 `import file` 语法而不是 `from file import` 来避免，并将所有不是全局定义的内容都包裹在
`if __name__ == "__main__":`
中。

## 导入的副作用
你第一次导入一个文件时，它会执行整个文件，然后让你访问在执行过程中定义的所有变量。
如果你再次导入同一个文件，它只会再次返回第一次缓存的模块。

这意味着 import 语句可能会有副作用。如果你导入一个调用 `harvest()` 的文件，它实际上会在导入过程中进行收获。但当你再次导入它时，它不会再次收获，因为文件只运行一次。

有一种方法可以使用 `__name__` 变量来避免这种副作用。当文件被直接运行时，这个变量会自动设置为 `"__main__"`，而当文件通过 `import` 运行时，它会被设置为文件名。
一个良好实践是，将任何你不想在文件被导入时运行的代码都放在 `if __name__ == "__main__":` 代码块内。

Python 中一个常见的文件结构是将文件运行时应执行的代码放入一个 `main()` 函数中。这样你就能清楚地区分局部变量（在 `main()` 内部定义）和可以被导入的全局变量（在 `main()` 外部定义）。

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # 做些事情

if __name__ == "__main__":
    main()`

## 循环导入
如果文件 `a` 导入文件 `b`，而文件 `b` 又导入文件 `a`，会发生什么？

文件 `a`：
`import b
x = 0`

文件 `b`：
`import a
def f():
    print(a.x)`

这会正常工作。假设这两个文件都还没有被加载，然后其他人执行了 `import a`。

-`a` 运行到 `import b` 这一行。
-`b` 运行到 `import a` 这一行。
-模块 `a` 已经存在，但不包含 `x`，因为它只运行到了 `import b` 这一行。
-`b` 将一个对加载了一半的模块 `a` 的引用存储在一个名为 `a` 的变量中。
-`b` 运行 `def` 语句并存储函数 `f()`。
-`a` 继续运行并初始化 `x`。

当有人调用 `b.f()` 时，它会正确地打印 `0`，因为 `b` 所引用的模块 `a` 现在已经完全加载了。

现在考虑使用 `from` 语法的相同代码。

文件 `a`：
`from b import *
x = 0`

文件 `b`：
`from a import *
def f():
    print(x)`

-`a` 运行到 `from b import *` 这一行。
-`b` 运行到 `from a import *` 这一行。
-模块 `a` 已经存在，但还没有被完全执行。
-`b` 将当前在 `a` 中的所有内容解包到它自己的全局 scope 中。此时，`a` 中什么都没有，因为它还没有执行到 `x = 0` 这一行，所以没有导入任何东西。
-`b` 运行 `def` 语句并存储函数 `f()`。
-`a` 继续运行并初始化 `x`。

如果现在有人调用 `b.f()`，他们会得到一个 error，说 `x` 在当前 scope 中不存在。这是因为这一次 `b` 没有对仍在加载的 `a` 的引用，也看不到在导入后添加的定义。