# 命名作用域 (Scope)
Scope 决定了可以从哪里访问哪些变量。Scope 基本上是一个从名称到值的映射。
它们的工作方式与 Python 中的基本相同。

有一个全局 scope，每个函数都有一个局部 scope。
当你定义一个变量时，它会被添加到当前的 scope 中。
函数定义之外的任何东西都被认为是全局 scope 的一部分。

`x = 1`
在全局 scope 中将值 `1` 赋给名称 `x`。

这个 `def` 语句在全局 scope 中将一个函数赋给名称 `f`。
`def f():
    `在 f 的局部 scope 中将值 `1` 赋给名称 `y`。`
    y = 1

    `在 f 的局部 scope 中将一个函数赋给名称 `g`。`
    def g():
        pass`

`f()`
从全局 scope 中检索存储在 `f` 中的函数并调用它。

`print(y)`
这个在全局 scope 中的 print 语句会抛出一个 error，因为 `y` 从未在全局 scope 中声明，所以我们无法在这里读取它。
它只存在于 `f` 的局部 scope 中。

## global 关键字
默认情况下，函数中的所有变量都绑定到局部 scope，即使全局 scope 中存在同名变量。

`x = 0

def f():
    x = 1
f()
print(x)`

这段代码会打印 `0`，因为 `f` 内部的局部 `x` 与全局 `x` 不是同一个变量，所以全局 `x` 保持不变。这很重要，因为否则函数调用可能会意外覆盖一个恰好与该函数局部变量同名的全局变量。

如果你想写入一个全局变量，你必须使用 `global` 关键字明确地这样做。

`x = 0

def f():
    global x
    x = 1
f()
print(x)`

在这个例子中，`global x` 将 `x` 绑定到它上面定义的全局变量 `x`。现在这将打印 `1`。
注意，改变全局变量通常是走向面条代码的第一步，即程序的每个部分都会影响到其他所有部分，所以不要滥用它。

## 循环和分支
循环和分支不会创建它们自己的 scope，所以它们内部声明的任何东西仍然可以在外部使用。

`for i in range(3):
    pass
print(i)`

这将打印 `2`，因为 `for` 循环的最后一次迭代将 `2` 赋给了 `i`。