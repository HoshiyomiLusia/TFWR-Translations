# 이름 Scope
Scope는 어떤 변수에 어디서 접근할 수 있는지를 결정합니다. Scope는 기본적으로 이름과 값의 매핑입니다.
기본적으로 파이썬과 동일하게 작동합니다.

전역 scope가 있고, 각 함수에는 지역 scope가 있습니다.
변수를 정의하면 현재 scope에 추가됩니다.
함수 정의 외부의 모든 것은 전역 scope의 일부로 간주됩니다.

`x = 1`
전역 scope에서 이름 `x`에 값 `1`을 할당합니다.

이 `def` 문은 전역 scope에서 이름 `f`에 함수를 할당합니다.
`def f():
    `'f'의 지역 scope에서 이름 `y`에 값 `1`을 할당합니다.`
    y = 1

    `'f'의 지역 scope에서 이름 `g`에 함수를 할당합니다.`
    def g():
        pass`

`f()`
전역 scope에서 `f`에 저장된 함수를 검색하여 호출합니다.

`print(y)`
전역 scope의 이 print 문은 `y`가 전역 scope에 선언된 적이 없으므로 여기서 읽을 수 없어 error를 발생시킵니다.
`y`는 `f`의 지역 scope에만 존재했습니다.

## global 키워드
기본적으로 함수 내의 모든 변수는 지역 scope에 바인딩됩니다. 심지어 전역 scope에 같은 이름의 변수가 존재하더라도 마찬가지입니다.

`x = 0

def f():
    x = 1
f()
print(x)`

이 코드는 `0`을 출력합니다. `f` 내부의 지역 `x`는 전역 `x`와 같은 변수가 아니므로 전역 `x`는 변경되지 않기 때문입니다. 이것은 중요합니다. 그렇지 않으면 함수 호출이 우연히 해당 함수의 지역 변수와 이름이 같은 전역 변수를 덮어쓸 수 있기 때문입니다.

전역 변수에 쓰려면 `global` 키워드를 사용하여 명시적으로 그렇게 해야 합니다.

`x = 0

def f():
    global x
    x = 1
f()
print(x)`

이 예제에서 `global x`는 `x`를 그 위에 정의된 전역 변수 `x`에 바인딩합니다. 이제 이 코드는 `1`을 출력합니다.
전역 변수를 변경하는 것은 보통 프로그램의 모든 부분이 다른 모든 부분에 영향을 미치는 스파게티 코드로 가는 첫걸음이므로 남용하지 마세요.

## 루프와 분기
루프와 분기는 자체 scope를 만들지 않으므로, 그 안에서 선언된 모든 것은 밖에서도 사용할 수 있습니다.

`for i in range(3):
    pass
print(i)`

이 코드는 `2`를 출력합니다. `for` 루프의 마지막 반복이 `i`에 `2`를 할당했기 때문입니다.