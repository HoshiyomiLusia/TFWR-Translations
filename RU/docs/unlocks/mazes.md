# Лабиринты
`Items.Weird_Substance`, которое можно получить, [удобряя](docs/unlocks/fertilizer.md) растения, оказывает странный эффект на кусты. Если дрон находится над кустом и вы вызовете `use_item(Items.Weird_Substance, amount)`, куст вырастет в лабиринт из живой изгороди.
Размер лабиринта зависит от количества использованного `Items.Weird_Substance` (второй аргумент вызова `use_item()`).
Без улучшений лабиринта, использование `n` `Items.Weird_Substance` приведёт к созданию лабиринта `n`x`n`. Каждый уровень улучшения лабиринта удваивает сокровище, но также удваивает необходимое количество `Items.Weird_Substance`. 
Так что для создания лабиринта на всё поле:

`plant(Entities.Bush)
substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, substance)`


По какой-то причине дрон не может летать над живой изгородью, хотя она и не выглядит такой уж высокой.

Где-то в изгороди спрятано сокровище. Используйте `harvest()` на сокровище, чтобы получить золото, равное площади лабиринта. (Например, лабиринт 5x5 даст 25 золота.)

Если вы используете `harvest()` в любом другом месте, лабиринт просто исчезнет.

`get_entity_type()` равно `Entities.Treasure`, если дрон над сокровищем, и `Entities.Hedge` во всех остальных местах лабиринта.

Лабиринты не содержат петель, если вы не используете лабиринт повторно (см. ниже, как это сделать). Так что у дрона нет способа оказаться в той же позиции снова, не возвращаясь назад.

Вы можете проверить, есть ли стена, попытавшись пройти сквозь неё. 
`move()` возвращает `True` в случае успеха и `False` в противном случае.

`can_move()` можно использовать, чтобы проверить, есть ли стена, без движения.

Если вы не знаете, как добраться до сокровища, загляните в Подсказку 1. Она показывает, как подойти к подобной проблеме.

Использование `measure()` в любом месте лабиринта возвращает позицию сокровища.
`x, y = measure()`

Для дополнительного испытания вы можете также повторно использовать лабиринт, применив то же количество `Items.Weird_Substance` к сокровищу снова. 
Это увеличит количество золота в сокровище на стоимость целого лабиринта и переместит его в случайное место в лабиринте.

Каждый раз, когда сокровище перемещается, из лабиринта может быть удалена случайная стена. Так что в повторно используемых лабиринтах могут быть петли.

Обратите внимание, что петли в лабиринте значительно усложняют его, потому что это означает, что вы можете снова попасть в то же место, не двигаясь назад.
Повторное использование лабиринта не даёт больше золота, чем просто сбор сокровища и создание нового лабиринта.
Это на 100% дополнительное испытание, которое вы можете просто пропустить.
Оно того стоит, только если дополнительная информация и короткие пути помогут вам решить лабиринт быстрее.

Один и тот же лабиринт можно решить максимум 300 раз. Это соответствует 299 перемещениям. После этого использование странной субстанции на сокровище больше не будет увеличивать количество золота в нём, и `measure()` вернёт `None`.

<spoiler=показать подсказку 1>Вот общий подход к решению проблемы:

Создайте лабиринт и представьте, что вы — дрон.

Подумайте, как бы вы пытались найти сокровище, находясь в лабиринте.

Запишите свою стратегию шаг за шагом, чтобы кто-то другой мог следовать ей, не задумываясь.

Теперь попробуйте перевести ваши шаги в код.
</spoiler>
<spoiler=показать подсказку 2>Пока нет петель: все стены на самом деле — это одна большая соединённая стена. Если вы будете следовать вдоль стены, она проведёт вас через весь лабиринт.
Этот подход требует очень мало кода, и вам не нужно отслеживать, где вы уже были. Около 10 строк кода — это всё, что вам нужно.</spoiler>
<spoiler=показать подсказку 3>Вместо того чтобы двигать дрон в абсолютных направлениях, таких как восток или запад, может быть очень полезно двигать его в относительных направлениях, таких как «повернуть направо» или «повернуть налево». Для этого вам нужно отслеживать, в какую сторону дрон движется в данный момент. Дрон на самом деле никогда не поворачивается, но вы всё равно можете поддерживать «виртуальный» поворот в коде.
Следующий трюк с индексами может быть полезен для этого:

`directions = [North, East, South, West]
index = 0`

Используйте `% 4`, чтобы позволить ему вращаться «по кругу», так что после `West` он вернётся к `North`.
`# повернуть направо
index = (index + 1) % 4`

`# повернуть налево
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=показать подсказку 4>Если вы не можете решить его, вы всегда можете облегчить себе жизнь и сделать это менее эффективно. 
Решить лабиринт `1`x`1` — это тривиально.</spoiler>