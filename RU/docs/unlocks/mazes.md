# Лабиринты
`Items.Weird_Substance`, получаемое при [удобрении](docs/unlocks/fertilizer.md) растений, оказывает странное воздействие на кусты. Если дрон находится над кустом, и вы вызываете `use_item(Items.Weird_Substance, amount)`, куст вырастет в лабиринт из живой изгороди.
Размер лабиринта зависит от количества использованного `Items.Weird_Substance` (второй аргумент вызова `use_item()`).
Без улучшений лабиринта использование `n` `Items.Weird_Substance` приведёт к лабиринту `n`x`n`. Каждый уровень улучшения лабиринта удваивает сокровище, но также удваивает необходимое количество `Items.Weird_Substance`. 
Итак, чтобы сделать лабиринт на всё поле:

`plant(Entities.Bush)
substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, substance)`


По какой-то причине дрон не может летать над изгородями, хотя они и не выглядят такими уж высокими.

Где-то в изгороди спрятано сокровище. Используйте `harvest()` на сокровище, чтобы получить золото, равное площади лабиринта. (Например, лабиринт 5x5 принесёт 25 золота.)

Если вы используете `harvest()` в любом другом месте, лабиринт просто исчезнет.

`get_entity_type()` равно `Entities.Treasure`, если дрон находится над сокровищем, и `Entities.Hedge` во всех остальных местах лабиринта.

Лабиринты не содержат петель, если вы не используете лабиринт повторно (см. ниже, как это сделать). Так что у дрона нет способа оказаться в той же позиции снова, не возвращаясь назад.

Вы можете проверить, есть ли стена, попытавшись пройти сквозь неё. 
`move()` возвращает `True`, если удалось, и `False` в противном случае.

`can_move()` можно использовать для проверки наличия стены без движения.

Если вы не знаете, как добраться до сокровища, посмотрите Подсказку 1. Она показывает, как подходить к подобной проблеме.

Использование `measure()` в любом месте лабиринта возвращает позицию сокровища.
`x, y = measure()`

Для дополнительного испытания вы также можете повторно использовать лабиринт, применив то же количество `Items.Weird_Substance` на сокровище снова. 
Это увеличит количество золота в сокровище на один полный лабиринт и переместит его в случайную позицию в лабиринте.

Каждый раз, когда сокровище перемещается, из лабиринта может быть удалена случайная стена. Так что повторно используемые лабиринты могут содержать петли.

Обратите внимание, что петли в лабиринте делают его намного сложнее, потому что это означает, что вы можете попасть в то же место снова, не возвращаясь назад.
Повторное использование лабиринта не даёт больше золота, чем просто сбор и создание нового лабиринта.
Это 100% дополнительное испытание, которое вы можете просто пропустить.
Оно того стоит, только если дополнительная информация и короткие пути помогут вам решить лабиринт быстрее.

Один и тот же лабиринт можно решить максимум 300 раз. Это соответствует 299 перемещениям. После этого использование странной субстанции на сокровище больше не будет увеличивать золото в нём, и `measure()` вернёт `None`.

<spoiler=показать подсказку 1>Вот общий подход к решению проблемы:

Создайте лабиринт и представьте, что вы — дрон.

Подумайте, как бы вы пытались найти сокровище, если бы были в лабиринте.

Запишите свою стратегию шаг за шагом, чтобы кто-то другой мог следовать ей, не задумываясь.

Теперь попробуйте перевести ваши шаги в код.
</spoiler>
<spoiler=показать подсказку 2>Пока нет петель: все стены на самом деле являются одной большой соединённой стеной. Если вы будете следовать вдоль стены, она проведёт вас через весь лабиринт.
Этот подход требует очень мало кода, и вам не нужно отслеживать, где вы уже были. Около 10 строк кода — это всё, что вам нужно.</spoiler>
<spoiler=показать подсказку 3>Вместо того, чтобы двигать дрона в абсолютных направлениях, таких как восток или запад, может быть очень полезно двигать дрона в относительных направлениях, таких как «повернуть направо» или «повернуть налево». Для этого вам нужно отслеживать, в каком направлении дрон сейчас движется. Дрон на самом деле никогда не вращается, но вы всё равно можете поддерживать «виртуальное» вращение в коде.
Следующий трюк с индексами для этого полезен:

`directions = [North, East, South, West]
index = 0`

Используйте `% 4`, чтобы позволить ему вращаться «по кругу», так что после `West` он вернётся к `North`.
`# повернуть направо
index = (index + 1) % 4`

`# повернуть налево
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=показать подсказку 4>Если вы не можете решить, вы всегда можете облегчить себе жизнь и сделать это менее эффективно. 
Решить лабиринт `1`x`1` тривиально.</spoiler>