# 迷路
植物を[肥料やり](docs/unlocks/fertilizer.md)することで得られる`Items.Weird_Substance`は、茂みに奇妙な効果をもたらします。ドローンが茂みの上にあるときに`use_item(Items.Weird_Substance, amount)`を呼び出すと、茂みは生け垣の迷路に成長します。
迷路のサイズは、使用された`Items.Weird_Substance`の量（`use_item()`呼び出しの2番目の引数）によって決まります。
迷路のアップグレードがない場合、`n`個の`Items.Weird_Substance`を使用すると`n`x`n`の迷路ができます。迷路のアップグレードレベルごとに宝物は2倍になりますが、必要な`Items.Weird_Substance`の量も2倍になります。
したがって、フィールドいっぱいの迷路を作るには：

`plant(Entities.Bush)
substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, substance)`


どういうわけか、生け垣はそれほど高そうに見えませんが、ドローンは飛び越えることができません。

生け垣のどこかに宝物が隠されています。宝物に対して`harvest()`を使用すると、迷路の面積に等しいゴールドを受け取ります。（例：5x5の迷路では25ゴールドが手に入ります。）

他の場所で`harvest()`を使用すると、迷路は単に消えてしまいます。

ドローンが宝物の上にある場合、`get_entity_type()`は`Entities.Treasure`に等しく、迷路の他の場所では`Entities.Hedge`に等しくなります。

迷路を再利用しない限り（迷路の再利用方法については下記参照）、迷路にはループは含まれません。そのため、ドローンが後戻りせずに同じ位置に戻ることはありません。

壁があるかどうかは、そこを通り抜けようとすることで確認できます。
`move()`は成功した場合は`True`を、失敗した場合は`False`を返します。

`can_move()`を使えば、移動せずに壁があるかどうかを確認できます。

宝物への行き方が分からない場合は、ヒント1を見てください。このような問題への取り組み方が示されています。

迷路のどこかで`measure()`を使用すると、宝物の位置が返されます。
`x, y = measure()`

さらなる挑戦として、宝物に対して再度同量の`Items.Weird_Substance`を使用することで、迷路を再利用することもできます。
これにより、宝物の中のゴールドが迷路1つ分増加し、宝物は迷路内のランダムな位置に移動します。

宝物が移動するたびに、迷路からランダムな壁が取り除かれることがあります。そのため、再利用された迷路にはループが含まれることがあります。

迷路にループがあると、後戻りせずに同じ場所に戻ることができるため、難易度が大幅に上がりますので注意してください。
迷路を再利用しても、単に収穫して新しい迷路を生成するよりも多くのゴールドが得られるわけではありません。
これは100%、スキップしても構わない追加の挑戦です。
追加情報やショートカットが迷路をより速く解決するのに役立つ場合にのみ、価値があります。

同じ迷路は最大300回まで解くことができます。これは299回の再配置に相当します。その後は、宝物に奇妙な物質を使用してもゴールドは増加しなくなり、`measure()`は`None`を返します。

<spoiler=ヒント1を表示>問題を解決するための一般的なアプローチは次のとおりです：

迷路を作成し、自分がドローンになったと想像してみてください。

もし自分が迷路の中にいたら、どうやって宝物を見つけようとするか考えてみましょう。

他の人が考えなくても従えるように、あなたの戦略をステップバイステップで書き出してください。

次に、そのステップをコードに翻訳してみてください。
</spoiler>
<spoiler=ヒント2を表示>ループがない限り：すべての壁は実際には一つの大きなつながった壁です。壁に沿って進めば、迷路全体を通り抜けることができます。
このアプローチは非常に少ないコードで済み、どこに行ったかを記録する必要もありません。必要なのは10行程度のコードだけです。</spoiler>
<spoiler=ヒント3を表示>ドローンを東や西のような絶対的な方向に動かす代わりに、「右に曲がる」や「左に曲がる」のような相対的な方向に動かすと非常に便利です。そのためには、ドローンが現在どの方向を向いているかを記録し続ける必要があります。ドローンは実際には回転しませんが、コード内で「仮想的」な向きを保持することができます。
このためには、次のインデックスのトリックが役立ちます：

`directions = [North, East, South, West]
index = 0`

`% 4`を使うと、「円を一周する」ように回転させることができます。つまり、`West`の後は`North`に戻ります。
`# turn right
index = (index + 1) % 4`

`# turn left
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=ヒント4を表示>もし解けない場合は、いつでも楽をして、効率の悪い方法で解決することができます。
`1`x`1`の迷路を解くのは簡単です。</spoiler>