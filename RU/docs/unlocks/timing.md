# Тайминги
Если вы действительно хотите оптимизировать свои методы, вам нужно понять, как измеряется время в этой игре. Это улучшение как раз об этом.

## Новые функции
Есть две полезные функции, чтобы измерять, сколько времени что-то занимает:

`get_time()` возвращает время в секундах с начала игры.

`get_tick_count()` возвращает количество ticks, выполненных с начала выполнения.

Эти две функции, а также `quick_print()`, абсолютно бесплатны. Даже операция вызова для них бесплатна.

## Детали выполнения

### Внимание
Производительность в реальном мире работает не так. Это просто правила, придуманные для этой игры, чтобы иметь последовательную и понятную модель времени.
Вероятно, это будет вас волновать, только если вы хотите гипер-оптимизировать свой код.


Базовая единица времени для выполнения кода называется «tick». Без улучшений скорости и энергии, выполнение происходит со скоростью `400` ticks в секунду.

В общем, операции, которые комбинируют два значения, такие как `+, -, *, /, //, %, and, or, ...`, занимают один tick.
Одиночные `-` и `not` бесплатны.
Ветвь `if` также занимает один tick (в дополнение ко времени, необходимому для вычисления выражения условия).
Вызовы функций, а также чтение и запись переменных бесплатны, но определение функций занимает 1 tick.
Инструкции `import` бесплатны.
Доступ к импортированному модулю с помощью оператора `.` бесплатен.
Если функция или модуль были переданы через аргументы или присваивания переменных, их использование будет стоить 1 tick вместо 0.
Циклы `for` и `while` занимают один tick для запуска, но итерации бесплатны (не считая времени на вычисление выражений условия/последовательности).
`return`, `break` и `continue` все бесплатны.
`pass` занимает один tick, так что его можно использовать для создания точных задержек.
Индексация в структуру данных занимает один tick для оператора индексации и, в случае dict или set, дополнительные ticks в зависимости от размера ключа.

Количество ticks, которое занимают встроенные функции, документировано на странице каждой функции индивидуально.