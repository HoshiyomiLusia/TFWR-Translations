# Лабиринты
`Items.Weird_Substance`, получаемые при [удобрении](docs/unlocks/fertilizer.md) растений, оказывают странное воздействие на кусты. Если дрон находится над кустом и вы вызываете `use_item(Items.Weird_Substance, amount)`, куст вырастет в лабиринт из живой изгороди.
Размер лабиринта зависит от количества использованного `Items.Weird_Substance` (второй аргумент вызова `use_item()`).
Без улучшений лабиринта использование `n` `Items.Weird_Substance` приведёт к лабиринту `n`x`n`. Каждый уровень улучшения лабиринта удваивает сокровище, но также удваивает необходимое количество `Items.Weird_Substance`. 
Так что, чтобы создать лабиринт на всё поле:

`plant(Entities.Bush)
n_substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, n_substance)`


По какой-то причине дрон не может летать над живой изгородью, хотя она не выглядит такой уж высокой.

Где-то в изгороди спрятано сокровище. Используйте `harvest()` на сокровище, чтобы получить золото, равное площади лабиринта. (Например, лабиринт 5x5 даст 25 золота.)

Если вы используете `harvest()` в любом другом месте, лабиринт просто исчезнет.

`get_entity_type()` равен `Entities.Treasure`, если дрон находится над сокровищем, и `Entities.Hedge` во всех остальных местах лабиринта.

Лабиринты не содержат циклов, если только вы не используете лабиринт повторно (см. ниже, как повторно использовать лабиринт). Так что у дрона нет способа снова оказаться на той же позиции, не возвращаясь назад.

Вы можете проверить, есть ли стена, попытавшись пройти через неё. 
`move()` возвращает `True`, если удалось, и `False` в противном случае.

Если вы понятия не имеете, как добраться до сокровища, взгляните на Подсказку 1. Она показывает, как подходить к подобной задаче.


Для дополнительной сложности вы также можете повторно использовать лабиринт, применив то же количество `Items.Weird_Substance` на сокровище снова. 
Это увеличит количество золота в сокровище на один полный лабиринт и переместит его в случайное место в лабиринте.

Использование `measure()` на сокровище возвращает позицию, на которую оно переместится, в виде tuple.
`next_x, next_y = measure()`

Каждый раз, когда сокровище перемещается, случайная стена может быть удалена из лабиринта. Так что повторно используемые лабиринты могут содержать циклы.

Обратите внимание, что циклы в лабиринте делают его намного сложнее, потому что это означает, что вы можете снова попасть в то же место, не двигаясь назад.
Повторное использование лабиринта не даёт больше золота, чем просто сбор урожая и создание нового лабиринта.
Это 100% дополнительное испытание, которое вы можете просто пропустить.
Оно того стоит, только если дополнительная информация и короткие пути помогут вам решить лабиринт быстрее.

Один и тот же лабиринт можно решить максимум 300 раз. Это соответствует 299 перемещениям. После этого использование странной субстанции на сокровище больше не будет увеличивать золото в нём, а `measure()` вернёт `None`.

<spoiler=показать подсказку 1>Вот общий подход к решению проблемы:

Создайте лабиринт и представьте, что вы — дрон.

Подумайте, как бы вы попытались найти сокровище, если бы были в лабиринте.

Запишите свою стратегию шаг за шагом, чтобы кто-то другой мог следовать ей, не задумываясь.

Теперь попробуйте перевести ваши шаги в код.
</spoiler>
<spoiler=показать подсказку 2>Пока нет циклов: все стены — это на самом деле одна большая соединённая стена. Если вы будете следовать вдоль стены, она проведёт вас через весь лабиринт.
Этот подход требует очень мало кода, и вам не нужно отслеживать, где вы уже были. Около 10 строк кода — это всё, что вам нужно.</spoiler>
<spoiler=показать подсказку 3>Вместо того чтобы перемещать дрон в абсолютных направлениях, таких как восток или запад, может быть очень полезно перемещать дрон в относительных направлениях, таких как "повернуть направо" или "повернуть налево". Для этого вам нужно отслеживать, в какую сторону в данный момент движется дрон. Дрон на самом деле никогда не поворачивается, но вы всё равно можете поддерживать "виртуальное" вращение в коде.
Следующий трюк с индексом полезен для этого:

`directions = [North, East, South, West]
index = 0`

Используйте `% 4`, чтобы позволить ему вращаться "по кругу", так что после `West` он вернётся к `North`.
`# повернуть направо
index = (index + 1) % 4`

`# повернуть налево
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=показать подсказку 4>Если вы не можете решить эту задачу, вы всегда можете облегчить себе жизнь и сделать это менее эффективно. 
Решить лабиринт `1`x`1` тривиально.</spoiler>