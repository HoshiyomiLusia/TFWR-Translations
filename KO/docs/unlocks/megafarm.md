# 메가 농장
이 놀라운 잠금 해제는 농장 크기를 크게 증가시키고 여러 드론을 사용할 수 있게 해 줘요.

더 쉽게 하기 위해, 새로운 드론마다 정확히 36개의 새로운 타일을 받게 돼요. 드론과 타일의 비율은 일정하게 유지돼요.

## 여러 대의 드론
이전처럼, 여전히 하나의 드론으로 시작해요. 추가적인 드론은 먼저 생성되어야 하며 프로그램이 끝나면 사라져요. 각 드론은 자신의 독립적인 프로그램 인스턴스를 실행해요. 드론은 다음을 사용하여 새로운 드론을 생성할 수 있어요:
`new_drone_id = spawn_drone("filename")`

이것은 `spawn_drone("filename")` 명령어를 실행한 드론과 동일한 위치에 새로운 드론을 생성해요. 새로운 드론은 `filename` 이름의 파일에 있는 프로그램을 실행할 것이므로, `"filename"`을 실행하고 싶은 파일의 이름으로 바꿔주세요.

이것은 여러분의 드론에게 `filename` 이름의 파일로 가서 다음 드론의 실행 버튼을 클릭하라고 말하는 것처럼 생각할 수 있어요.

드론은 서로 충돌하지 않아요.

`max_drones()`를 사용하여 생성할 수 있는 드론의 최대 수를 확인해요.
`num_drones()`를 사용하여 이미 농장에 있는 드론의 수를 확인해요.
`get_drone_id()`를 사용하여 어떤 드론이 코드를 실행 중인지 알아봐요.

예시:

`farming routine`이라는 파일에서:
`if get_drone_id() == 0:
    # 첫 번째 드론만 이 코드를 실행해요
    while num_drones() < max_drones():
        spawn_drone("farming routine")
        move(East)`

while True:
    if can_harvest():
        harvest()
    move(North)`

이 코드는 첫 번째 드론이 가로로 이동하면서 더 많은 드론들을 생성하도록 만들고, 생성된 드론들은 세로로 이동하며 경로에 있는 모든 것을 수확할 거예요.

<spoiler=힌트 보기>여러 대의 드론을 사용하는 가장 쉬운 방법은 드론들 사이에 농장을 나누는 거예요. 업그레이드는 각 드론이 항상 6x6 필드를 가질 수 있도록 설계되었어요.
</spoiler>

### 여기 아래 모든 것은 꽤 고급스럽고 기본적인 농사에는 필요하지 않아요

## 경쟁 상태
여러 드론은 동시에 같은 농장 타일과 상호 작용할 수 있어요. 만약 두 드론이 정확히 같은 틱 동안 같은 타일과 상호 작용하면, 더 낮은 드론 ID를 가진 드론의 작업이 먼저 수행돼요.

예를 들어, 드론 `0`와 `1`이 거의 자라난 나무 위에 동시에 있다고 상상해 봅시다.
드론 `0`은 다음을 호출해요:
`use_item(Items.Fertilizer)`
드론 `1`은 다음을 호출해요:
`harvest()`

이 작업이 동시에 발생하면, 나무는 먼저 비료가 주어지고 그 다음 수확될 거예요. 이 경우, 나무에서 목재를 받게 될 거예요. 그러나 만약 드론 `1`이 조금 더 빠르면, 비료가 주어지기 전에 나무가 수확되어, 목재를 받지 못하게 돼요.
이것을 "경쟁 상태"라고 부르며, 이는 병렬 프로그래밍에서 흔히 발생하는 문제로, 결과물이 작업이 수행되는 순서에 따라 달라져요.

또 다른 문제가 발생할 수 있는 상황입니다. 여러 드론이 동일한 위치에서 동시에 동일한 코드를 실행할 때 발생할 수 있어요.
`if get_water() < 0.5:
    use_item(Items.Water)`

여러 드론이 동시에 이 코드 블록을 실행하면 첫 번째 줄을 모두 실행하게 되고, 그들은 모두 `if` 블록 안으로 들어가요. 그런 다음, 그들은 모두 물을 사용하게 되며 많은 물이 낭비돼요.
드론이 두 번째 줄에 도착할 때쯤이면, 다른 드론이 타일에 물을 주었기 때문에 `get_water()`가 더 이상 `0.5`보다 작지 않을 수도 있어요.

## 드론 통신
좀 더 고급 전략을 원하는 경우, 드론끼리 메시지 전달 함수를 사용해 서로 통신할 수 있어요. 

다른 드론에게 값을 보내기:
`send(data, receiver_drone_id)`

어떤 드론에서든 보낸 다음 값을 받기:
`data = receive()`

특정 드론에서 보낸 값을 받기:
`data = receive(sender_drone_id)`

`send()`의 실행 시간은 보낸 데이터의 크기에 따라 달라져요. 예를 들어, 큰 dictionary를 보내면 복사가 필요하므로 시간이 걸릴 수 있어요.

`receive()`는 메시지가 도착하기를 기다리지 않아요. 아직 메시지가 보내진 게 없으면 `None`을 반환하게 돼요.

이렇게 메시지를 기다리는 함수를 만들 수 있어요:
`def blocking_receive(sender_drone_id = -1):
    while True:
        data = receive(sender_drone_id)
        if data != None:
            return data`

메시지를 전달하는 것의 유용한 응용 예시는 드론을 생성하고 그 드론에게 실행할 함수를 보내는 거예요.
`drone_spawning`이라는 파일에:
`def run_on_new_drone(f):
    id = spawn_drone("drone_spawning")
    send(f, id)

if __name__ == "__main__":
    f = blocking_receive()
    f()`

그렇게 함수를 보내는 것은 매우 느릴 수 있어요. 함수의 모든 상태와 모든 글로벌 변수가 복사되어야 하기 때문이에요.