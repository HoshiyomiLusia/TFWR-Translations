# インポート
すべてのコードを1つのファイルに入れると、すぐに管理が難しくなります。
`import`ステートメントを使うと、他のファイルから関数やグローバル変数をインポートできます。

`import filename`

これは最も単純な形式のインポートステートメントです。これにより、`filename`という名前のファイルで定義されているすべてにアクセスできます。ゲーム内の各ウィンドウはファイルであり、ファイル名はウィンドウの上部に表示される名前です。

2つのファイルを使った例です:
helperという名前のファイル:
`x = 0

def say_hello():
    print("hello from helper")`

別のファイル:
`import helper
helper.say_hello()
helper.x += 1`

ここで`import helper`は`helper`という名前のファイルを実行し、そのすべてのグローバル変数へのアクセスを提供します。
インポートされたモジュール内の変数や関数には、`.`演算子を使ってアクセスできます。
この例では、`helper.say_hello()`はhelper内の`say_hello()`を呼び出し、最後の行はグローバル変数xをインクリメントします。

`from`構文を使って、インポートされたモジュールから現在のscopeにグローバル変数を移動させることもできます。

`from helper import *`
helperからすべてのグローバル変数をインポートします。

または

`from helper import say_hello`
helperから指定されたグローバル変数のみをインポートします。

これもhelperファイルをインポートしますが、`helper`という名前の変数を通してアクセスする代わりに、`helper`からグローバル変数をアンパックし、ローカルscopeに直接割り当てます。

`from helper import say_hello
say_hello()`

この形式のインポートは、2つのファイルが互いにインポートする場合にうまく機能せず、名前の衝突によってインポート元のファイルの変数を誤って上書きしてしまう可能性があるため、通常は推奨されません。

# 実際の仕組み

## 要約
インポートはかなり直感的でない場合がありますが、ほとんどの問題は`from file import`の代わりに`import file`構文に固執し、グローバル定義でないものすべてを
`if __name__ == "__main__":`
で囲むことで回避できます。

## インポートの副作用
ファイルを初めてインポートすると、ファイル全体が実行され、実行中に定義されたすべての変数にアクセスできるようになります。
同じファイルを再度インポートすると、初回にキャッシュされたモジュールが再度返されるだけです。

これは、インポートステートメントに副作用がある可能性があることを意味します。`harvest()`を呼び出すファイルをインポートすると、インポート中に実際に収穫が行われます。しかし、再度インポートしても、ファイルは一度しか実行されないため、再び収穫されることはありません。

`__name__`変数を使って、このような副作用を避ける方法があります。これは、ファイルが直接実行されたときには自動的に`"__main__"`に設定され、`import`を通じて実行されたときにはファイル名に設定される変数です。
ファイルがインポートされたときに実行したくないコードは、`if __name__ == "__main__":`ブロック内に入れるのが良い習慣とされています。

Pythonでの一般的なファイル構造は、ファイルが実行されたときに実行されるべきコードを`main()`関数に入れることです。これにより、ローカル変数（`main()`内で定義）とインポート可能なグローバル変数（`main()`外で定義）を明確に区別できます。

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # いろいろやる

if __name__ == "__main__":
    main()`

## インポートサイクル
ファイル`a`がファイル`b`をインポートし、ファイル`b`がファイル`a`をインポートするとどうなるでしょうか？

ファイル `a`:
`import b
x = 0`

ファイル `b`:
`import a
def f():
    print(a.x)`

これは問題なく動作します。どちらのファイルもまだロードされておらず、誰かが`import a`を実行したとしましょう。

-`a`は`import b`の行まで実行されます。
-`b`は`import a`の行まで実行されます。
-モジュール`a`は既に存在しますが、`import b`の行にしか到達していないため、`x`は含まれていません。
-`b`は半分ロードされたモジュール`a`への参照を`a`という名前の変数に保存します。
-`b`は`def`ステートメントを実行し、関数`f()`を保存します。
-`a`は実行を続け、`x`を初期化します。

誰かが`b.f()`を呼び出すと、`b`が参照しているモジュール`a`が完全にロードされているため、正しく`0`と表示されます。

さて、同じコードを`from`構文で考えてみましょう。

ファイル `a`:
`from b import *
x = 0`

ファイル `b`:
`from a import *
def f():
    print(x)`

-`a`は`from b import *`の行まで実行されます。
-`b`は`from a import *`の行まで実行されます。
-モジュール`a`は既に存在しますが、まだ完全に実行されていません。
-`b`は現在`a`にあるすべてを自身のグローバルscopeにアンパックします。この時点で`a`は`x = 0`の行に到達していないため、何も含まれておらず、何もインポートされません。
-`b`は`def`ステートメントを実行し、関数`f()`を保存します。
-`a`は実行を続け、`x`を初期化します。

もし誰かが`b.f()`を呼び出すと、現在のscopeに`x`が存在しないというerrorが発生します。これは、今回`b`がまだロード中の`a`への参照を持っておらず、インポート後に追加された定義を見ることができないためです。