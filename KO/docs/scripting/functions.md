# 함수
`def` 키워드를 사용하여 새 함수를 정의합니다:
`def f(arg1, arg2 = False):
	#함수 코드`

호출 연산자 `()`를 사용하여 함수를 호출할 수 있습니다:
`f(42)`

함수 내의 지역 변수와 전역 변수에 대해 배우려면 [Scopes](docs/scripting/scopes.md)도 참조하세요.

## 소개
이미 `harvest()`와 같은 내장 함수를 보셨을 겁니다.
자신만의 함수를 정의하여 코드를 모듈식으로 구조화할 수도 있습니다. 기본적으로 코드 블록에 이름을 부여하여 원하는 곳 어디에서나 호출할 수 있게 해줍니다.

## 함수 정의
예를 들어, 드론을 여러 번 움직이는 함수를 정의할 수 있습니다.

`def move_n_dir(n, dir):
	for i in range(n):
		move(dir)`

`def` 키워드는 이것이 함수 정의임을 나타냅니다.
`move_n_dir`은 함수가 바인딩되는 이름입니다. 이것은 유효한 변수 이름일 수 있으며 함수를 호출하는 데 사용됩니다.
`n`과 `dir`은 매개변수입니다. 이것들은 함수에 전달되는 값(이 값들은 인자라고도 함)을 담는 변수입니다. 함수 정의에 원하는 만큼 많은 매개변수를 추가할 수 있습니다.
`:` 뒤에는 함수가 호출될 때 실행될 코드 블록이 옵니다.

위 정의를 사용하면 다음 코드는 드론을 `North`로 `10` 타일, `West`로 `2` 타일 이동시킵니다.

`move_n_dir(10, North)
move_n_dir(2, West)`

`def function():`를 볼 때, 다음과 같은 변수 할당으로 생각해야 합니다:
`function = create_new_function_object()`
모든 할당과 마찬가지로, 변수가 할당되기 전에 사용할 수 없습니다!
`def` 문은 함수 호출 전에 실행되어야 합니다.
이 코드는 error를 발생시킵니다:

`func()
def func():
	pass`

## 반환 값
`return` 키워드를 사용하여 함수가 값을 반환하게 합니다.
예를 들어, 다음 함수는 배타적 논리합(exclusive or) 연산을 정의합니다. 배타적 논리합은 한 값이 `True`이고 다른 값이 `False`일 때 `True`를 반환합니다:

`def xor(a, b):
	return a != b

if xor(True, False):
	do_a_flip()`

[Tuples](docs/scripting/tuples.md)는 여러 값을 반환할 수 있게 합니다.

## 기본 인자
인자가 전달되지 않을 경우 사용될 기본값을 할당할 수도 있습니다.

`def f(a = False):
	if a:
		do_a_flip()

f()

f(True)`

기본값이 있는 인자 뒤에는 기본값이 없는 인자가 올 수 없습니다.

## 고급 함수 사용법
함수는 다른 값들과 마찬가지로 값이며, `def` 문은 단순히 할당문처럼 작동하여 함수를 여러분이 부여한 이름에 할당합니다.
이것은 다음과 같은 것을 가능하게 합니다:

`def f():
	def d():
		do_a_flip()
	return d

f()()`

여기서 `f()`는 함수 `f`를 호출하고, `f`는 새로운 함수 `d`를 정의하고 반환합니다. 그 다음 두 번째 `()`는 반환된 함수를 실행하여 공중제비를 합니다.
(이런 종류의 작업은 무슨 일이 일어나는지 파악하기 어렵기 때문에 보통 좋은 생각이 아닙니다)

다른 함수를 인자로 받는 함수는 여러분을 정말 창의적으로 만들어 줍니다:

`def f(g, arg):
	for _ in range(10):
		g(arg)

f(move, North)
f(use_item, Items.Fertilizer)`

이 코드는 드론을 `North`로 10번 움직인 다음 비료를 10번 사용합니다.